---
layout: post
title: "代码随想录"
date: 2023-07-23
description: "代码随想录笔记"
tag: 算法
---

### 前言

	`dmsxl算法题记录。`

### 目录

* [第一章](#chapter1)
* [第二章](#chapter2)
* [第三章](#chapter3)
* [第四章](#chapter4)
* [第五章](#chapter5)
* [第六章](#chapter6)
* [第七章](#chapter7)
* [第八章](#chapter8)
* [第九章](#chapter9)

### <a name="chapter1"></a>第一章 算法性能分析

#### 时间复杂度 ####

#### 空间复杂度 ####

### <a name="chapter2"></a>第二章 数组

#### 数组理论基础 ####

#### 704. 二分查找 ####

![](https://s3.uuu.ovh/imgs/2023/07/24/c02bdfb0df4d021e.png)

	class Solution {
	public:
	    vector<int> sortedSquares(vector<int>& nums) {
	        int i = 0;
	        int j = nums.size() - 1;
	        vector<int> result(nums.size(), 0);
	        for (int index = nums.size() - 1; index >= 0; index--) {
	            if (nums[i] * nums[i] >= nums[j] * nums[j]) {
	                result[index] = nums[i] * nums[i];
	                i++;
	            } else {
	                result[index] = nums[j] * nums[j];
	                j--;
	            }
	        }
	
	        return result;
	    }
	};

#### 27. 移除元素 ####

![](https://s3.uuu.ovh/imgs/2023/07/24/09995037a9fcb07b.png)

	class Solution {
	public:
	    int removeElement(vector<int>& nums, int val) {
	        int slowIndex = 0;
	        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
	            if (nums[fastIndex] != val) {
	                nums[slowIndex] = nums[fastIndex];
	                slowIndex++;
	            }
	        }
	
	        return slowIndex;
	    }
	};

#### 977. 有序数组的平方 ####

![](https://s3.uuu.ovh/imgs/2023/07/24/305fe87ddd3c68b3.png)

	class Solution {
	public:
	    vector<int> sortedSquares(vector<int>& nums) {
	        int i = 0;
	        int j = nums.size() - 1;
	        vector<int> result(nums.size(), 0);
	        for (int index = nums.size() - 1; index >= 0; index--) {
	            if (nums[i] * nums[i] >= nums[j] * nums[j]) {
	                result[index] = nums[i] * nums[i];
	                i++;
	            } else {
	                result[index] = nums[j] * nums[j];
	                j--;
	            }
	        }
	
	        return result;
	    }
	};

#### 209. 长度最小的子数组 ####

![](https://s3.uuu.ovh/imgs/2023/07/24/17f8f4d8e91d4eca.png)

	class Solution {
	public:
	    int minSubArrayLen(int target, vector<int>& nums) {
	        int slowIndex = 0;
	        int fastIndex = 0;
	        int sum = nums[0];
	        int length = 0;
	        while (true) {
	            if (sum >= target) {
	                if (((fastIndex - slowIndex + 1) < length || (length == 0))) {
	                    length = fastIndex - slowIndex + 1;
	                    if (length == 1) {
	                        break;
	                    }
	                }
	                
	                sum -= nums[slowIndex];
	                slowIndex++;
	            } else {
	                fastIndex++;
	                if (fastIndex >= nums.size()) {
	                    break;
	                }
	                sum += nums[fastIndex];
	            }
	        }
	
	        return length;
	    }
	};

#### 59. 螺旋矩阵 II ####

![](https://s3.uuu.ovh/imgs/2023/07/25/74d20cec0c2290d0.png)

	class Solution {
	public:
	    vector<vector<int>> generateMatrix(int n) {
	        vector<vector<int>> result(n, vector<int>(n, 0));
	        int start = 0;
	        int end = (n + 1) / 2;
	        int num = 1;
	        while (start < end) {
	            for (int i = start; i < n - start; i++) {
	                result[start][i] = num;
	                num++;
	            }
	
	            if (num >= n * n) {
	                break;
	            }
	
	            for (int i = start + 1; i < (n - 1 - start); i++) {
	                result[i][n - 1 - start] = num;
	                num++;
	            }
	
	            for (int i = n - start - 1; i >= start; i--) {
	                result[n - 1 - start][i] = num;
	                num++;
	            }
	
	            for (int i = n - start - 2; i >= start + 1; i--) {
	                result[i][start] = num;
	                num++;
	            }
	
	            start++;
	        }
	
	        return result;
	    }
	};

### <a name="chapter3"></a>第三章 链表

#### 链表理论基础 ####

#### 203. 移除链表元素 ####

![](https://s3.uuu.ovh/imgs/2023/07/29/a12e9e11fe6010e6.png)

	class Solution {
	public:
	    ListNode* removeElements(ListNode* head, int val) {
	        if (head == nullptr) {
	            return nullptr;
	        }
	
	        ListNode *dummy = new ListNode(-1, head);
	        ListNode *preNode = dummy;
	        ListNode *node = head;
	        while (node != nullptr) {
	            if (node->val == val) {
	                preNode->next = node->next;
	                ListNode *temp = node;
	                node = node->next;
	                delete temp;
	            } else {
	                preNode = node;
	                node = node->next;
	            }
	        }
	
	        return dummy->next;
	    }
	};

#### 707. 设计链表 ####

![](https://s3.bmp.ovh/imgs/2023/07/29/a70c5b6da96be23e.png)

	class MyLinkedList {
	public:
	    struct ListNode {
	        int val;
	        ListNode *next;
	        ListNode() : val(0), next(nullptr) {}
	        ListNode(int x) : val(x), next(nullptr) {}
	        ListNode(int x, ListNode *next) : val(x), next(next) {}  
	    };
	
	    ListNode *head;
	    ListNode *tail;
	    int size;
	
	    MyLinkedList() {
	        head = nullptr;
	        tail = nullptr;
	        size = 0;
	    }
	    
	    int get(int index) {
	        if (index < 0 || index >= size) {
	            return -1;
	        }
	
	        ListNode *node = head;
	        int result = node->val;
	        index--;
	        while (index >= 0 && node->next) {
	            node = node->next;
	            result = node->val;
	            index--;
	        }
	
	        return result;
	    }
	    
	    void addAtHead(int val) {
	        ListNode *node = new ListNode(val, head);
	        if (!head) {
	            head = node;
	            tail = node;
	        } else {
	            head = node;
	        }
	
	        size++;
	    }
	    
	    void addAtTail(int val) {
	        ListNode *node = new ListNode(val, nullptr);
	        if (!tail) {
	            head = node;
	            tail = node;
	        } else {
	            tail->next = node;
	            tail = node;
	        }
	
	        size++;
	    }
	    
	    void addAtIndex(int index, int val) {
	        if (index < 0 || index > size) {
	            return;
	        }
	
	        ListNode *newNode = new ListNode(val, nullptr);
	        ListNode *dummy = new ListNode(-1, head);
	        ListNode *node = head;
	        
	        if (size == 0) {
	            head = newNode;
	            tail = newNode;
	            size++;
	            return;
	        }
	
	        if (index == size) {
	            tail->next = newNode;
	            tail = newNode;
	            size++;
	            return;
	        }
	        index--;
	        while (index >= 0) {
	            index--;
	            dummy = node;
	            node = node->next;
	        }
	
	        if (dummy->val == -1) {
	            dummy->next = newNode;
	            newNode->next = node;
	            head = dummy->next;
	        } else {
	            dummy->next = newNode;
	            newNode->next = node;
	        }
	
	        size++;
	    }
	    
	    void deleteAtIndex(int index) {
	        if (index < 0 || index >= size) {
	            return;
	        } else if (size == 1) {
	            head = nullptr;
	            tail = nullptr;
	            size--;
	            return;
	        }
	
	        ListNode *dummy = new ListNode(-1, head);
	        ListNode *node = head;
	        index--;
	        while (index >= 0) {
	            index--;
	            dummy = node;
	            node = node->next;
	        }
	
	        if (dummy->val == -1) {
	            dummy->next = node->next;
	            head = dummy->next;
	        } else {
	            dummy->next = node->next;
	        }
	
	        if (!dummy->next) {
	            tail = dummy;
	        }
	
	        size--;
	        return;
	    }
	};
	
	/**
	 * Your MyLinkedList object will be instantiated and called as such:
	 * MyLinkedList* obj = new MyLinkedList();
	 * int param_1 = obj->get(index);
	 * obj->addAtHead(val);
	 * obj->addAtTail(val);
	 * obj->addAtIndex(index,val);
	 * obj->deleteAtIndex(index);
	 */

#### 206. 反转链表 ####

![](https://s3.uuu.ovh/imgs/2023/07/29/1df1f56b19a977a1.png)

	class Solution {
	public:
	    ListNode* reverseList(ListNode* head) {
	        if (head == nullptr) {
	            return nullptr;
	        }
	
	        ListNode *node = head->next;
	        ListNode *pre = head;
	        pre->next = nullptr;
	        while (node != nullptr) {
	            ListNode *temp = node;
	            node = node->next;
	            temp->next = pre;
	            pre = temp;
	        }
	
	        return pre;
	    }
	};

#### 24. 两两交换链表中的节点 ####

![](https://s3.uuu.ovh/imgs/2023/07/30/6758cf06ea1d7e68.png)

	class Solution {
	public:
	    ListNode* swapPairs(ListNode* head) {
	        if (head == nullptr) {
	            return nullptr;
	        }
	
	        ListNode *first = head;
	        ListNode *second = first->next;
	        ListNode *pre = nullptr;
	        while (first && first->next) {
	            second = first->next;
	            ListNode *tempFirst = first;
	            first = second->next;
	            second->next = tempFirst;
	            tempFirst->next = first;
	            if (pre) {
	                pre->next = second;
	            }
	
	            pre = tempFirst;
	            if (tempFirst == head) {
	                head = second;
	            }
	        }
	
	        return head;
	    }
	};

#### 19. 删除链表的倒数第 N 个结点 ####

![](https://s3.uuu.ovh/imgs/2023/08/03/11abddcb5768ebe3.png)

	class Solution {
	public:
	    ListNode* removeNthFromEnd(ListNode* head, int n) {
	        ListNode *dummy = new ListNode(-1, head);
	        ListNode *slow = dummy;
	        ListNode *fast = head;
	        while (n-- && fast) {
	            fast = fast->next;
	        }
	
	        while (fast) {
	            slow = slow->next;
	            fast = fast->next;
	        }
	
	        slow->next = slow->next->next;
	        if (slow->val == -1) {
	            head = slow->next;
	        }
	        return head;
	    }
	};

#### 面试题 02.07. 链表相交 ####

![](https://s3.uuu.ovh/imgs/2023/08/04/c7de879791de1064.png)

	class Solution {
	public:
	    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
	        int lengthA = 0;
	        int lengthB = 0;
	        ListNode *nodeA = headA;
	        ListNode *nodeB = headB;
	        while (nodeA) {
	            lengthA++;
	            nodeA = nodeA->next;
	        }
	
	        while (nodeB) {
	            lengthB++;
	            nodeB = nodeB->next;
	        }
	
	        int gap = abs(lengthA - lengthB);
	        if (lengthA >= lengthB) {
	            nodeA = headA;
	            nodeB = headB;
	        } else {
	            nodeA = headB;
	            nodeB = headA;
	        }
	
	        while (gap > 0) {
	            nodeA = nodeA->next;
	            gap--;
	        }
	
	        while (nodeA && nodeB) {
	            if (nodeA == nodeB) {
	                return nodeA;
	            }
	
	            nodeA = nodeA->next;
	            nodeB = nodeB->next;
	        }
	
	        return nullptr;
	    }
	};

#### 142. 环形链表 II ####

![](https://s3.uuu.ovh/imgs/2023/08/06/491f98449d0069e5.png)

	class Solution {
	public:
	    ListNode *detectCycle(ListNode *head) {
	        ListNode *slowNode = head;
	        ListNode *fastNode = head;
	        while (slowNode && fastNode) {
	            slowNode = slowNode->next;
	            if (!slowNode) {
	                return nullptr;
	            }
	
	            fastNode = fastNode->next;
	            if (!fastNode) {
	                return nullptr;
	            }
	
	            fastNode = fastNode->next;
	            if (!fastNode) {
	                return nullptr;
	            }
	
	            if (slowNode == fastNode) {
	                break;
	            }
	        }
	
	        slowNode = head;
	        while (slowNode != fastNode) {
	            slowNode = slowNode->next;
	            fastNode = fastNode->next;
	        }
	
	        return slowNode;
	    }
	};

### <a name="chapter4"></a>第四章 哈希表

#### 242. 有效的字母异位词 ####

![](https://s3.uuu.ovh/imgs/2023/08/07/18a6a4a7475e1382.png)

	class Solution {
	public:
	    bool isAnagram(string s, string t) {
	        unordered_map<char, int> hashMap;
	        for (int i = 0; i < s.size(); i++) {
	            hashMap[s[i]]++;
	        }
	
	        for (int i = 0; i < t.size(); i++) {
	            hashMap[t[i]]--;
	        }
	
	        for (auto iter : hashMap) {
	            if (iter.second != 0) {
	                return false;
	            }
	        }
	
	        return true;
	    }
	};

#### 349. 两个数组的交集 ####

![](https://s3.uuu.ovh/imgs/2023/08/07/227c5d97707b8c53.png)

	class Solution {
	public:
	    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
	        unordered_set<int> hashSet;
	        vector<int> result;
	        for (int i = 0; i < nums1.size(); i++) {
	            hashSet.insert(nums1[i]);
	        }
	
	        for (int i = 0; i < nums2.size(); i++) {
	            if (hashSet.find(nums2[i]) != hashSet.end()) {
	                if (find(result.begin(), result.end(), nums2[i]) == result.end()) {
	                    result.emplace_back(nums2[i]);
	                }
	            }
	        }
	
	        return result;
	    }
	};

#### 202. 快乐数 ####

![](https://s3.uuu.ovh/imgs/2023/08/09/0e5641406295f73d.png)

	class Solution {
	public:
	    bool isHappy(int n) {
	        unordered_set<int> nums;
	        int num = n;
	        while (true) {
	            int sNum = 0;
	            while (num > 0) {
	                int single = num % 10;
	                num = num / 10;
	                sNum += single *single;
	            }
	
	            num = sNum;
	            if (nums.find(sNum) != nums.end()) {
	                return false;
	            }
	
	            if (sNum == 1) {
	                return true;
	            }
	
	            nums.insert(sNum);
	        }
	
	        return true;
	    }
	};

#### 1. 两数之和 ####

![](https://s3.uuu.ovh/imgs/2023/08/13/9dbab8ab9b4dc436.png)

	class Solution {
	public:
	    vector<int> twoSum(vector<int>& nums, int target) {
	        unordered_map<int, int> hashMap;
	        for (int i = 0; i < nums.size(); i++) {
	            auto iter = hashMap.find(target - nums[i]);
	            if (iter != hashMap.end()) {
	                return {i, iter->second};
	            }
	
	            hashMap.insert(pair<int, int>(nums[i], i));
	        }
	
	        return {};
	    }
	};

#### 454. 四数相加 II ####

![](https://s3.uuu.ovh/imgs/2023/08/13/b6901fbc7f2c6a18.png)

	class Solution {
	public:
	    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
	        int result = 0;
	        unordered_map<int, int> hashMap;
	        for (int i = 0; i < nums1.size(); i++) {
	            for (int j = 0; j < nums2.size(); j++) {
	                hashMap[nums1[i] + nums2[j]]++;
	            }
	        }
	
	        for (int i = 0; i < nums3.size(); i++) {
	            for (int j = 0; j < nums4.size(); j++) {
	                int num = -(nums3[i] + nums4[j]);
	                if (hashMap.find(num) != hashMap.end()) {
	                    result += hashMap[num];
	                }
	            }
	        }
	
	        return result;
	    }
	};

#### 383. 赎金信 ####

![](https://s3.uuu.ovh/imgs/2023/08/15/bb5e7d3baf1b3362.png)

	class Solution {
	public:
	    bool canConstruct(string ransomNote, string magazine) {
	        unordered_map<int, int> hashMap;
	        for (int i = 0; i < magazine.size(); i++) {
	            hashMap[magazine[i]]++;
	        }
	
	        for (int i = 0; i < ransomNote.size(); i++) {
	            auto iter = hashMap.find(ransomNote[i]);
	            if (iter == hashMap.end() || iter->second <= 0) {
	                return false;
	            }
	
	            iter->second--;
	        }
	
	        return true;
	    }
	};

#### 15. 三数之和 ####

![](https://s3.uuu.ovh/imgs/2023/08/22/8b19bb45c4418ade.png)

	class Solution {
	public:
	    vector<vector<int>> threeSum(vector<int>& nums) {
	        vector<vector<int>> result;
	        sort(nums.begin(), nums.end());
	        for (int i = 0; i < nums.size(); i++) {
	            if (nums[i] > 0) {
	                return result;
	            }
	
	            if (i > 0 && nums[i] == nums[i - 1]) {
	                continue;
	            }
	
	            int left = i + 1;
	            int right = nums.size() - 1;
	            while (left < right) {
	                if (nums[i] + nums[left] + nums[right] == 0) {
	                    result.emplace_back(vector<int>{nums[i], nums[left], nums[right]});
	                    while (left + 1 < nums.size() && nums[left] == nums[left + 1]) {
	                        left++;
	                    }
	
	                    while (right - 1 >= 0 && nums[right] == nums[right - 1]) {
	                        right--;
	                    }
	
	                    left++;
	                    right--;
	                } else if (nums[i] + nums[left] + nums[right] > 0) {
	                    right--;
	                } else {
	                    left++;
	                }
	            }
	        }
	
	        return result;
	    }
	};

#### 18. 四数之和 ####

![](https://s3.uuu.ovh/imgs/2023/08/23/ab0b0dc1954cb6d2.png)

	class Solution {
	public:
	    vector<vector<int>> fourSum(vector<int>& nums, int target) {
	        vector<vector<int>> result;
	        sort(nums.begin(), nums.end());
	        for (int i = 0; i < nums.size(); i++) {
	            if (i > 0 && nums[i] == nums[i - 1]) {
	                continue;
	            }
	
	            for (int j = i + 1; j < nums.size(); j++) {
	                if (j > i + 1 && nums[j] == nums[j - 1]) {
	                    continue;
	                }
	
	                int left = j + 1;
	                int right = nums.size() - 1;
	                while (left < right) {
	                    if ((long)nums[i] + nums[j] + nums[left] + nums[right] > target) {
	                        right--;
	                    } else if ((long)nums[i] + nums[j] + nums[left] + nums[right] < target) {
	                        left++;
	                    } else {
	                        result.emplace_back(vector<int>{nums[i], nums[j], nums[left], nums[right]});
	                        while (left < right && nums[left] == nums[left + 1]) left++;
	                        while (left < right && nums[right] == nums[right - 1]) right--;
	                        left++;
	                        right--;
	                    }
	                }
	            }
	        }
	
	        return result;
	    }
	};

### <a name="chapter5"></a>第五章 字符串

#### 344. 反转字符串 ####

![](https://s3.uuu.ovh/imgs/2023/08/23/7f4b5cb3d35526e7.png)

	class Solution {
	public:
	    void reverseString(vector<char>& s) {
	        int left = 0;
	        int right = s.size() - 1;
	        while (left < right) {
	            char tmp = s[left];
	            s[left] = s[right];
	            s[right] = tmp;
	            left++;
	            right--;
	        }
	    }
	};

#### 541. 反转字符串 II ####

![](https://s3.uuu.ovh/imgs/2023/08/23/ecfd63eb2a720a70.png)

	class Solution {
	public:
	    string reverseStr(string s, int k) {
	        int pos = 0;
	        for (int i = 2 * k - 1; i < s.size(); i += 2 *k) {
	            reverse(s.begin() + pos, s.begin() + pos + k);
	            pos = i + 1;
	        }
	
	        if (s.size() - pos > k) {
	            reverse(s.begin() + pos, s.begin() + pos + k);
	        } else {
	            reverse(s.begin() + pos, s.end());
	        }
	
	        return s;
	    }
	};

#### 剑指 Offer 05. 替换空格 ####

![](https://s3.uuu.ovh/imgs/2023/08/23/3219b9c29daf3940.png)

	class Solution {
	public:
	    string replaceSpace(string s) {
	        int left = s.size() - 1;
	        int spaceNum = 0;
	        for (int i = 0; i < s.size(); i++) {
	            if (s[i] == ' ') {
	                spaceNum++;
	            }
	        }
	
	        s.resize(left + 1 + 2 * spaceNum);
	        int right = s.size() - 1;
	        while (left >= 0) {
	            if (s[left] != ' ') {
	                s[right--] = s[left--];
	            } else {
	                s[right--] = '0';
	                s[right--] = '2';
	                s[right--] = '%';
	                left--;
	            }
	        }
	
	        return s;
	    }
	};

#### 151. 反转字符串中的单词 ####

![](https://s3.uuu.ovh/imgs/2023/08/25/cc62a0df1541fc5c.png)

	class Solution {
	public:
	    string reverseWords(string s) {
	        int slow = 0; 
	        for (int i = 0; i < s.size(); ++i) {
	            if (s[i] != ' ') {
	                if (slow != 0) s[slow++] = ' ';
	                while (i < s.size() && s[i] != ' ') {
	                    s[slow++] = s[i++];
	                }
	            }
	        }
	        s.resize(slow);
	
	        int pos = 0;
	        int valid = 0;
	        string result = "";
	        for (int i = 0; i < s.size(); i++) {
	            if (s[i] == ' ') {
	                reverse(s.begin() + pos, s.begin() + i);
	                pos = i + 1;
	                valid = 0;
	            }
	        }
	
	        reverse(s.begin() + pos, s.end());
	        reverse(s.begin(), s.end());
	        return s;
	    }
	};

#### 剑指 Offer 58 - II. 左旋转字符串 ####

![](https://s3.uuu.ovh/imgs/2023/08/25/660ad836f3ec9e52.png)

	class Solution {
	public:
	    string reverseLeftWords(string s, int n) {
	        reverse(s.begin(), s.end());
	        reverse(s.begin(), s.begin() + s.size() - n);
	        reverse(s.begin() + s.size() -n, s.end());
	        return s;
	    }
	};

#### 28. 找出字符串中第一个匹配项的下标 ####

![](https://s3.uuu.ovh/imgs/2023/08/26/6e09fbeb4ff08672.png)

	class Solution {
	public:
	    int strStr(string haystack, string needle) {
	        if (needle.size() > haystack.size()) {
	            return -1;
	        }
	
	        int j = 0;
	        for (int i = 0; i < haystack.size() - needle.size() + 1; i++) {
	            int index = i;
	            for (j = 0; j < needle.size(); j++) {
	                if (haystack[index] == needle[j]) {
	                    index++;
	                    continue;
	                }
	
	                break;
	            }
	
	            if (j == needle.size()) {
	                return i;
	            }
	        }
	
	        return -1;
	    }
	};

#### 459. 重复的子字符串 ####

![](https://s3.uuu.ovh/imgs/2023/08/26/ebde6fadec0ab458.png)

	class Solution {
	public:
	    bool repeatedSubstringPattern(string s) {
	        for (int i = 1; i <= s.size() / 2; i++) {
	            if (s.size() % i != 0) {
	                continue;
	            }
	
	            string tmp = s.substr(0, i);
	            int j = i;
	            for (j = i; j < s.size(); j += i) {
	                if (s.substr(j, i) == tmp) {
	                    continue;
	                } else {
	                    break;
	                }
	            }
	
	            if (j == s.size()) {
	                return true;
	            }
	        }
	
	        return false;
	    }
	};

### <a name="chapter6"></a>第六章 双指针法

#### 27. 移除元素 ####

![](https://s3.uuu.ovh/imgs/2023/08/26/d0bf64ca8a6c0130.png)

	class Solution {
	public:
	    int removeElement(vector<int>& nums, int val) {
	        for (int i = 0; i < nums.size(); i++) {
	            if (nums[i] == val) {
	                nums.erase(nums.begin() + i);
	                i--;
	            }
	        }
	
	        return nums.size();
	    }
	};

### <a name="chapter7"></a>第气章 栈与队列

#### 232. 用栈实现队列 ####

![](https://s3.uuu.ovh/imgs/2023/08/26/e91faad59166f8d5.png)

	class MyQueue {
	public:
	    stack<int> stack1;
	    stack<int> stack2;
	
	    MyQueue() {
	
	    }
	    
	    void push(int x) {
	        if (stack1.empty() && stack2.empty()) {
	            stack1.push(x);
	        } else if (stack1.empty()) {
	            while (!stack2.empty()) {
	                int val = stack2.top();
	                stack2.pop();
	                stack1.push(val);
	            }
	
	            stack1.push(x);
	        } else {
	            stack1.push(x);
	        }
	    }
	    
	    int pop() {
	        if (!stack1.empty()) {
	            int val;
	            while (!stack1.empty()) {
	                val = stack1.top();
	                stack1.pop();
	                stack2.push(val);
	            }
	
	            stack2.pop();
	            return val;
	        } else {
	            int val = stack2.top();
	            stack2.pop();
	            return val;
	        }
	    }
	    
	    int peek() {
	        if (!stack1.empty()) {
	            while (!stack1.empty()) {
	                int val = stack1.top();
	                stack1.pop();
	                stack2.push(val);
	            }
	
	            return stack2.top();
	        } else {
	            int val = stack2.top();
	            return val;
	        }
	    }
	    
	    bool empty() {
	        if (stack1.empty() && stack2.empty()) {
	            return true;
	        }
	
	        return false;
	    }
	};
	
	/**
	 * Your MyQueue object will be instantiated and called as such:
	 * MyQueue* obj = new MyQueue();
	 * obj->push(x);
	 * int param_2 = obj->pop();
	 * int param_3 = obj->peek();
	 * bool param_4 = obj->empty();
	 */

#### 232. 用栈实现队列 ####

![](https://s3.bmp.ovh/imgs/2023/08/27/a7b59d77bdf92609.png)

	class MyStack {
	public:
	    queue<int> q1;
	    queue<int> q2;
	    MyStack() {
	
	    }
	    
	    void push(int x) {
	        if (q2.empty()) {
	            q1.push(x);
	        } else {
	            q2.push(x);
	        }
	    }
	    
	    int pop() {
	        if (q1.empty()) {
	            int val;
	            while (q2.size() > 1) {
	                val = q2.front();
	                q2.pop();
	                q1.push(val);
	            }
	
	            val = q2.front();
	            q2.pop();
	            return val;
	        } else {
	            int val;
	            while (q1.size() > 1) {
	                val = q1.front();
	                q1.pop();
	                q2.push(val);
	            }
	
	            val = q1.front();
	            q1.pop();
	            return val;
	        }
	    }
	    
	    int top() {
	        if (q1.empty()) {
	            int val;
	            while (q2.size() > 0) {
	                val = q2.front();
	                q2.pop();
	                q1.push(val);
	            }
	
	            return val;
	        } else {
	            int val;
	            while (q1.size() > 0) {
	                val = q1.front();
	                q1.pop();
	                q2.push(val);
	            }
	
	            return val;
	        }
	    }
	    
	    bool empty() {
	        if (q1.empty() && q2.empty()) {
	            return true;
	        }
	
	        return false;
	    }
	};
	
	/**
	 * Your MyStack object will be instantiated and called as such:
	 * MyStack* obj = new MyStack();
	 * obj->push(x);
	 * int param_2 = obj->pop();
	 * int param_3 = obj->top();
	 * bool param_4 = obj->empty();
	 */

#### 20. 有效的括号 ####

![](https://s3.uuu.ovh/imgs/2023/08/27/c56a0f7a396c0013.png)

	class Solution {
	public:
	    bool isValid(string s) {
	        stack<char> stk;
	        for (int i = 0; i < s.size(); i++) {
	            if (s[i] == '(' || s[i] == '[' || s[i] == '{') {
	                stk.push(s[i]);
	            } else if (!stk.empty()) {
	                char tmp = stk.top();
	                if (s[i] == ')') {
	                    if (tmp != '(') {
	                        return false;
	                    } else {
	                        stk.pop();
	                    }
	                } else if (s[i] == ']') {
	                    if (tmp != '[') {
	                        return false;
	                    } else {
	                        stk.pop();
	                    }
	                } else if (s[i] == '}') {
	                    if (tmp != '{') {
	                        return false;
	                    } else {
	                        stk.pop();
	                    }
	                }
	            } else {
	                return false;
	            }
	        }
	
	        if (stk.empty()) {
	            return true;
	        }
	
	        return false;
	    }
	};

#### 1047. 删除字符串中的所有相邻重复项 ####

![](https://s3.uuu.ovh/imgs/2023/09/03/b9858c1f782a9b8a.png)

	class Solution {
	public:
	    string removeDuplicates(string s) {
	        string result;
	        stack<char> stk;
	        for (int i = 0; i < s.size(); i++) {
	            if (stk.empty()) {
	                stk.push(s[i]);
	                continue;
	            }
	
	            char tmp = stk.top();
	            if (s[i] == tmp) {
	                stk.pop();
	            } else {
	                stk.push(s[i]);
	            }
	        }
	
	        while (!stk.empty()) {
	            result += stk.top();
	            stk.pop();
	        }
	
	        reverse(result.begin(), result.end());
	        return result;
	    }
	};

#### 150. 逆波兰表达式求值 ####

![](https://s3.uuu.ovh/imgs/2023/09/03/cc4d230bb85b448f.png)

	class Solution {
	public:
	    int evalRPN(vector<string>& tokens) {
	        stack<string> stk;
	        for (int i = 0; i < tokens.size(); i++) {
	            if (stk.empty() || (tokens[i] != "+" && tokens[i] != "-" && tokens[i] != "*" && tokens[i] != "/")) {
	                stk.push(tokens[i]);
	            } else {
	                int num;
	                int n2 = stoi(stk.top());
	                stk.pop();
	                int n1 = stoi(stk.top());
	                stk.pop();
	                if (tokens[i] == "+") {
	                    num = n1 + n2;
	                } else if (tokens[i] == "-") {
	                    num = n1 - n2;
	                } else if (tokens[i] == "*") {
	                    num = n1 * n2;
	                } else if (tokens[i] == "/") {
	                    num = n1 / n2;
	                }
	
	                stk.push(to_string(num));
	            }
	        }
	
	        return stoi(stk.top());
	    }
	};

#### 239. 滑动窗口最大值 ####

![](https://s3.uuu.ovh/imgs/2023/09/03/d17ae89cfd8c4959.png)

	class Solution {
	public:
	    class MyQueue {
	        public:
	        deque<int> dq;
	        void pop(int value) {
	            if (!dq.empty() && dq.front() == value) {
	                dq.pop_front();
	            }
	        }
	
	        void push_back(int value) {
	            if (dq.empty() || value <= dq.back()) {
	                dq.push_back(value);
	            } else {
	                while (!dq.empty() && value > dq.back()) {
	                    dq.pop_back();
	                }
	
	                dq.push_back(value);
	            }
	        }
	
	        int front() {
	            return dq.front();
	        }
	    };
	
	    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
	        vector<int> result;
	        MyQueue mq;
	        for (int i = 0; i < k; i++) {
	            mq.push_back(nums[i]);
	        }
	
	        result.push_back(mq.front());
	        for (int i = k; i < nums.size(); i++) {
	            mq.pop(nums[i - k]);
	            mq.push_back(nums[i]);
	            result.push_back(mq.front());
	        }
	
	        return result;
	    }
	};

#### <font color="#0000dd">347. 前 K 个高频元素</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/09/06/a2fd61168cd82859.png)

	class Solution {
	public:
	    class compare {
	    public:
	        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
	            return lhs.second > rhs.second;
	        }
	    };
	
	    vector<int> topKFrequent(vector<int>& nums, int k) {
	        vector<int> result;
	        unordered_map<int, int> hashMap;
	        for (int i = 0; i < nums.size(); i++) {
	            hashMap[nums[i]]++;
	        }
	
	        priority_queue<pair<int, int>, vector<pair<int, int>>, compare> priQue;
	        for (auto iter : hashMap) {
	            priQue.push(iter);
	            if (priQue.size() > k) {
	                priQue.pop();
	            }
	        }
	
	        for (int i = k - 1; i >= 0; i--) {
	            int tmpNum = priQue.top().first;
	            priQue.pop();
	            result.emplace_back(tmpNum);
	        }
	
	        return result;
	    }
	};

### <a name="chapter7"></a>第七章 二叉树

#### 144. 二叉树的前序遍历 ####

![](https://s3.uuu.ovh/imgs/2023/09/04/21f9fc2d3569c0ae.png)

	class Solution {
	public:
	    vector<int> result;
	    void preOrder(TreeNode *node) {
	        if (node == nullptr) {
	            return;
	        }
	
	        result.emplace_back(node->val);
	        preOrder(node->left);
	        preOrder(node->right);
	    }
	
	    vector<int> preorderTraversal(TreeNode* root) {
	        preOrder(root);
	        return result;
	    }
	};

#### 145. 二叉树的后序遍历 ####

![](https://s3.uuu.ovh/imgs/2023/09/04/fa859d5769fb6829.png)

	class Solution {
	public:
	    vector<int> result;
	    void postOrder(TreeNode *node) {
	        if (node == nullptr) {
	            return;
	        }
	
	        postOrder(node->left);
	        postOrder(node->right);
	        result.emplace_back(node->val);
	    }
	
	    vector<int> postorderTraversal(TreeNode* root) {
	        postOrder(root);
	        return result;
	    }
	};

#### 94. 二叉树的中序遍历 ####

![](https://s3.uuu.ovh/imgs/2023/09/04/ee453ad4814be538.png)

	class Solution {
	public:
	    vector<int> result;
	    void inOrder(TreeNode *node) {
	        if (node == nullptr) {
	            return;
	        }
	
	        inOrder(node->left);
	        result.emplace_back(node->val);
	        inOrder(node->right);
	    }
	
	    vector<int> inorderTraversal(TreeNode* root) {
	        inOrder(root);
	        return result;
	    }
	};

#### 102. 二叉树的层序遍历 ####

![](https://s3.uuu.ovh/imgs/2023/09/05/0fa71de2ee0dd319.png)

	class Solution {
	public:
	    vector<vector<int>> levelOrder(TreeNode* root) {
	        vector<vector<int>> result;
	        if (root == nullptr) {
	            return result;
	        }
	
	        queue<TreeNode*> treeQue;
	        treeQue.push(root);
	        while (!treeQue.empty()) {
	            int size = treeQue.size();
	            vector<int> path;
	            for (int i = 0; i < size; i++) {
	                TreeNode *node = treeQue.front();
	                treeQue.pop();
	                path.emplace_back(node->val);
	                if (node->left) {
	                    treeQue.push(node->left);
	                }
	
	                if (node->right) {
	                    treeQue.push(node->right);
	                }
	            }
	
	            result.emplace_back(path);
	        }
	
	        return result;
	    }
	};

#### 107. 二叉树的层序遍历 II ####

![](https://s3.uuu.ovh/imgs/2023/09/06/72112f90ccdb7981.png)

	class Solution {
	public:
	    vector<vector<int>> levelOrderBottom(TreeNode* root) {
	        vector<vector<int>> result;
	        if (root == nullptr) {
	            return result;
	        }
	
	        queue<TreeNode*> que;
	        que.push(root);
	        while (!que.empty()) {
	            int queNum = que.size();
	            vector<int> path;
	            for (int i = 0; i < queNum; i++) {
	                TreeNode *node = que.front();
	                que.pop();
	                path.emplace_back(node->val);
	                if (node->left) {
	                    que.push(node->left);
	                }
	
	                if (node->right) {
	                    que.push(node->right);
	                }
	            }
	
	            result.emplace_back(path);
	        }
	
	        reverse(result.begin(), result.end());
	        return result;
	    }
	};

#### 199. 二叉树的右视图 ####

![](https://s3.uuu.ovh/imgs/2023/09/06/0b83b5dc60acf123.png)

	class Solution {
	public:
	    vector<int> rightSideView(TreeNode* root) {
	        vector<int> result;
	        if (root == nullptr) {
	            return result;
	        }
	
	        queue<TreeNode*> que;
	        que.push(root);
	        while (!que.empty()) {
	            int queNum = que.size();
	            for (int i = 0; i < queNum; i++) {
	                TreeNode *node = que.front();
	                que.pop();
                    if (i == queNum - 1) {
	                    result.emplace_back(node->val);
                    }

	                if (node->left) {
	                    que.push(node->left);
	                }
	
	                if (node->right) {
	                    que.push(node->right);
	                }
	            }
	        }
	
	        return result;
	    }
	};

#### 637. 二叉树的层平均值 ####

![](https://s3.uuu.ovh/imgs/2023/09/06/8c869e704ecdef8c.png)

	class Solution {
	public:
	    vector<double> averageOfLevels(TreeNode* root) {
	        vector<double> result;
	        if (root == nullptr) {
	            return result;
	        }
	
	        queue<TreeNode*> que;
	        que.push(root);
	        while (!que.empty()) {
	            int queNum = que.size();
	            double sum = 0.0;
	            for (int i = 0; i < queNum; i++) {
	                TreeNode *node = que.front();
	                que.pop();
	                sum += node->val;
	                if (i == queNum - 1) {
	                    result.emplace_back(sum / queNum);
	                }
	
	                if (node->left) {
	                    que.push(node->left);
	                }
	
	                if (node->right) {
	                    que.push(node->right);
	                }
	            }
	        }
	
	        return result;
	    }
	};

#### 226. 翻转二叉树 ####

![](https://s3.uuu.ovh/imgs/2023/09/08/c17ee8519cd11dc4.png)

	class Solution {
	public:
	    void swapTreeNode(TreeNode *node) {
	        if (node == nullptr) {
	            return;
	        }
	
	        TreeNode *tmp = node->left;
	        node->left = node->right;
	        node->right = tmp;
	        swapTreeNode(node->left);
	        swapTreeNode(node->right);
	    }
	
	    TreeNode* invertTree(TreeNode* root) {
	        swapTreeNode(root);
	        return root;
	    }
	};

#### 101. 对称二叉树 ####

![](https://s3.uuu.ovh/imgs/2023/09/08/fd99503c7fe6f79c.png)

	class Solution {
	public:
	    bool preOrder(TreeNode *left, TreeNode *right) {
	        if (left == nullptr && right == nullptr) {
	            return true;
	        }
	
	        if ((left == nullptr || right == nullptr) || (left->val != right->val)) {
	            return false;
	        }
	        
	        return preOrder(left->left, right->right) && preOrder(left->right, right->left);
	    }
	
	    bool isSymmetric(TreeNode* root) {
	        return preOrder(root->left, root->right);
	    }
	};

#### 104. 二叉树的最大深度 ####

![](https://s3.uuu.ovh/imgs/2023/09/09/6575e4a296b9d3c7.png)

	class Solution {
	public:
	    int maxDepth(TreeNode* root) {
	        if (root == nullptr) {
	            return 0;
	        }
	        return 1 + max(maxDepth(root->left), maxDepth(root->right));
	    }
	};

#### 111. 二叉树的最小深度 ####

![](https://s3.uuu.ovh/imgs/2023/09/09/e5a6bc329278cc48.png)

	class Solution {
	public:
	    int minDepth(TreeNode* root) {
	        if (root == nullptr) {
	            return 0;
		    }
	
	        if (root->left && root->right) {
	            return 1 + min(minDepth(root->left), minDepth(root->right));
	        } else if (root->left) {
	            return 1 + minDepth(root->left);
	        } else if (root->right) {
	            return 1 + minDepth(root->right);
	        }
	
	        return 1;
	    }
	};

#### 222. 完全二叉树的节点个数 ####

![](https://s3.uuu.ovh/imgs/2023/09/11/ce474305e98d7ffd.png)

	class Solution {
	public:
	    int sum;
	    void preOrder(TreeNode *node) {
	        if (node == nullptr) {
	            return;
	        }
	
	        if (node->left) {
	            sum++;
	            preOrder(node->left);
	        }
	
	        if (node->right) {
	            sum++;
	            preOrder(node->right);
	        }
	    }
	
	    int countNodes(TreeNode* root) {
	        if (root == nullptr) {
	            return 0;
	        }
	
	        sum = 1;
	        preOrder(root);
	        return sum;
	    }
	};

#### 110. 平衡二叉树 ####

![](https://s3.uuu.ovh/imgs/2023/09/12/9f386c320dbc1a67.png)

	class Solution {
	public:
	    int getHeight(TreeNode *node) {
	        if (node == nullptr) {
	            return 0;
	        }
	
	        return 1 + max(getHeight(node->left), getHeight(node->right));
	    }
	
	    bool isBalanced(TreeNode* root) {
	        if (root == nullptr) {
	            return true;
	        }
	
	        int gap = abs(getHeight(root->left) - getHeight(root->right));
	        if (gap > 1) {
	            return false;
	        }
	            
	        return isBalanced(root->left) && isBalanced(root->right);
	    }
	};

#### 257. 二叉树的所有路径 ####

![](https://s3.uuu.ovh/imgs/2023/09/12/5458c812e6a78afd.png)

	class Solution {
	public:
	    vector<string> result;
	    vector<int> path;
	    void preOrder(TreeNode *node) {
	        if (node == nullptr) {
	            return;
	        }
	
	        path.emplace_back(node->val);
	        if (!node->left && !node->right) {
	            string onePath = "";
	            for (int i = 0; i < path.size(); i++) {
	                if (i == path.size() - 1) {
	                    onePath += to_string(path[i]);
	                    break;
	                }
	
	                onePath += to_string(path[i]);
	                onePath += "->";
	            }
	
	            result.emplace_back(onePath);
	        }
	
	        preOrder(node->left);
	        preOrder(node->right);
	        path.pop_back();
	        return;
	    }
	
	    vector<string> binaryTreePaths(TreeNode* root) {
	        preOrder(root);
	        return result;
	    }
	};

#### 404. 左叶子之和 ####

![](https://s3.uuu.ovh/imgs/2023/09/13/4b0d8749a1674c9c.png)

	class Solution {
	public:
	    int result;
	    void dfs(TreeNode *node, bool isLeft) {
	        if (node == nullptr) {
	            return;
	        }
	
	        if (!node->left && !node->right && isLeft) {
	            result += node->val;
	        }
	
	        dfs(node->left, true);
	        dfs(node->right, false);
	    }
	
	    int sumOfLeftLeaves(TreeNode* root) {
	        result = 0;
	        dfs(root, false);
	        return result;
	    }
	};

#### 513. 找树左下角的值 ####

![](https://s3.uuu.ovh/imgs/2023/09/13/b908a5a1a6daf1c2.png)

	class Solution {
	public:
	    int result;
	    int height;
	    void dfs(TreeNode *node, int curHeight) {
	        if (node == nullptr) {
	            return;
	        }
	
	        if (!node->left && !node->right && curHeight > height) {
	            result = node->val;
	            height = curHeight;
	        }
	
	        dfs(node->left, curHeight + 1);
	        dfs(node->right, curHeight + 1);
	    }
	
	    int findBottomLeftValue(TreeNode* root) {
	        result = 0;
	        height = 0;
	        dfs(root, 1);
	        return result;
	    }
	};

#### 112. 路径总和 ####

![](https://s3.uuu.ovh/imgs/2023/09/13/9d3bc76b8421c1ba.png)

	class Solution {
	public:
	    bool result;
	    int path;
	    void dfs(TreeNode *node, int targetSum) {
	        if (node == nullptr || result) {
	            return;
	        }
	
	        path += node->val;
	        if (!node->left && !node->right && path == targetSum) {
	            result = true;
	        }
	
	        dfs(node->left, targetSum);
	        dfs(node->right, targetSum);
	        path -= node->val;
	    }
	
	    bool hasPathSum(TreeNode* root, int targetSum) {
	        path = 0;
	        result = false;
	        dfs(root, targetSum);
	        return result;
	    }
	};

#### 106. 从中序与后序遍历序列构造二叉树 ####

![](https://s3.uuu.ovh/imgs/2023/09/14/c371eb64c59a34f6.png)

	class Solution {
	public:
	    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
	        if (inorder.empty()) {
	            return nullptr;
	        }
	
	        TreeNode *node = new TreeNode(postorder[postorder.size() - 1]);
	        int index;
	        for (index = 0; index < inorder.size(); index++) {
	            if (inorder[index] == postorder[postorder.size() - 1]) {
	                break;
	            }
	        }
	
	        vector<int> leftInorder(inorder.begin(), inorder.begin() + index);
	        vector<int> rightInorder(inorder.begin() + index + 1, inorder.end());
	        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());
	        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end() - 1);
	        node->left = buildTree(leftInorder, leftPostorder);
	        node->right = buildTree(rightInorder, rightPostorder);
	        return node;
	    }
	};

#### 654. 最大二叉树 ####

![](https://s3.uuu.ovh/imgs/2023/09/15/6700e1013cf8ef5f.png)

	class Solution {
	public:
	    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
	        if (nums.size() == 0) {
	            return nullptr;
	        }
	
	        int index = 0;
	        int num = -1;
	        for (int i = 0; i < nums.size(); i++) {
	            if (nums[i] > num) {
	                num = nums[i];
	                index = i;
	            }
	        }
	
	        TreeNode *node = new TreeNode(nums[index]);
	        vector<int> leftNums(nums.begin(), nums.begin() + index);
	        vector<int> rightNums(nums.begin() + index + 1, nums.end());
	        node->left = constructMaximumBinaryTree(leftNums);
	        node->right = constructMaximumBinaryTree(rightNums);
	        return node;
	    }
	};

#### 617. 合并二叉树 ####

![](https://s3.uuu.ovh/imgs/2023/09/15/488a0952aca78fa1.png)

	class Solution {
	public:
	    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
	        if (root1 == nullptr && root2 == nullptr) {
	            return nullptr;
	        }
	
	        if (root1 && root2) {
	            root1->val += root2->val;
	            root1->left = mergeTrees(root1->left, root2->left);
	            root1->right = mergeTrees(root1->right, root2->right);
	        } else if (root2) {
	            root1 = root2;
	            root1->left = mergeTrees(nullptr, root2->left);
	            root1->right = mergeTrees(nullptr, root2->right);
	        } else {
	            root1->left = mergeTrees(root1->left, nullptr);
	            root1->right = mergeTrees(root1->right, nullptr); 
	        }
	
	        return root1;
	    }
	};

#### 700. 二叉搜索树中的搜索 ####

![](https://s3.uuu.ovh/imgs/2023/09/16/69c97e428f327cfc.png)

	class Solution {
	public:
	    TreeNode* searchBST(TreeNode* root, int val) {
	        if (root == nullptr) {
	            return nullptr;
	        }
	
	        if (root->val == val) {
	            return root;
	        } else if (root->val < val) {
	            return searchBST(root->right, val);
	        } else {
	            return searchBST(root->left, val);
	        }
	    }
	};

#### 98. 验证二叉搜索树 ####

![](https://s3.uuu.ovh/imgs/2023/09/16/5b8398514599519b.png)

	class Solution {
	public:
	    vector<int> result;
	    void inorder(TreeNode *node) {
	        if (node == nullptr) {
	            return;
	        }
	
	        inorder(node->left);
	        result.emplace_back(node->val);
	        inorder(node->right);
	    }
	
	    bool isValidBST(TreeNode* root) {
	        if (root == nullptr) {
	            return true;
	        }
	
	        inorder(root);
	        for (int i = 1; i < result.size(); i++) {
	            if (result[i] <= result[i - 1]) {
	                return false;
	            }
	        }
	
	        return true;
	    }
	};

#### 236. 二叉树的最近公共祖先 ####

![](https://s3.uuu.ovh/imgs/2023/09/16/c72221590d3d1de2.png)

	class Solution {
	public:
	    TreeNode* postorder(TreeNode *node, TreeNode* p, TreeNode* q) {
	        if (node == nullptr) {
	            return nullptr;
	        }
	
	        TreeNode* left = postorder(node->left, p, q);
	        TreeNode* right = postorder(node->right, p, q);
	        if (node->val == p->val || node->val == q->val) {
	            return node;
	        } else if (left && right) {
	            return node;
	        } else if (left) {
	            return left;
	        } else if (right) {
	            return right;
	        } else {
	            return nullptr;
	        }
	    }
	
	    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
	        TreeNode* node = postorder(root, p, q);
	        return node;
	    }
	};

#### 235. 二叉搜索树的最近公共祖先 ####

![](https://s3.uuu.ovh/imgs/2023/09/18/e2356cf97dda13e1.png)

	class Solution {
	public:
	    bool isFind;
	    TreeNode *result;
	    void inorder(TreeNode *node, TreeNode *p, TreeNode *q) {
	        if (node == nullptr || isFind) {
	            return;
	        }
	
	        inorder(node->left, p, q);
	        inorder(node->right, p, q);
	        if ((node->val >= p->val && node->val <= q->val) || (node->val <= p->val && node->val >= q->val)) {
	            isFind = true;
	            result = node;
	        }
	    }
	
	    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
	        isFind = false;
	        inorder(root, p, q);
	        return result;
	    }
	};

#### <font color="#0000dd">701. 二叉搜索树中的插入操作</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/09/20/3d7033fbd4759838.png)

	class Solution {
	public:
	    void preorder(TreeNode *node, TreeNode *parent, int val) {
	        if (node == nullptr) {
	            TreeNode *newNode = new TreeNode(val);
	            if (parent->val > val) {
	                parent->left = newNode;
	            } else {
	                parent->right = newNode;
	            }
	
	            return;
	        }
	
	        if (node->val > val) {
	            preorder(node->left, node, val);
	        } else {
	            preorder(node->right, node, val);
	        }
	    }
	
	    TreeNode* insertIntoBST(TreeNode* root, int val) {
	        if (root == nullptr) {
	            root = new TreeNode(val);
	            return root;
	        }
	
	        if (root->val > val) {
	            preorder(root->left, root, val);
	        } else {
	            preorder(root->right, root, val);
	        }
	
	        return root;
	    }
	};

#### <font color="#0000dd">450. 删除二叉搜索树中的节点</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/09/21/314256418e7205f3.png)

	class Solution {
	public:
	    TreeNode* deleteNode(TreeNode* root, int key) {
	        if (root == nullptr) {
	            return nullptr;
	        }
	
	        if (root->val == key) {
	            cout << root->val << endl;
	            if (!root->left && !root->right) {
	                return nullptr;
	            } else if (root->left && root->right) {
	                TreeNode *tmpR = root->right;
	                while (tmpR->left) {
	                    tmpR = tmpR->left;
	                }
	
	                tmpR->left = root->left;
	                return root->right;
	            } else if (root->left) {
	                return root->left;
	            } else {
	                return root->right;
	            }
	        } else if (root->val > key) {
	            root->left = deleteNode(root->left, key);
	        } else {
	            root->right = deleteNode(root->right, key);
	        }
	
	        return root;
	    }
	};

#### 669. 修剪二叉搜索树 ####

![](https://s3.uuu.ovh/imgs/2023/09/21/0b59f70fa8639e71.png)

	class Solution {
	public:
	    TreeNode* trimBST(TreeNode* root, int low, int high) {
	        if (root == nullptr) {
	            return nullptr;
	        }
	
	        if (root->val > high || root->val < low) {
	            TreeNode *node = root->val > high ? root->left : root->right;
	            while (node && (node->val > high || node->val < low)) {
	                if (node->val > high) {
	                    node = node->left;
	                } else {
	                    node = node->right;
	                }
	            }
	
	            return trimBST(node, low, high);
	        }
	
	        root->left = trimBST(root->left, low, high);
	        root->right = trimBST(root->right, low, high);
	        return root;
	    }
	};

#### 108. 将有序数组转换为二叉搜索树 ####

![](https://s3.uuu.ovh/imgs/2023/09/23/6e5bf9bca2c3f2f6.png)

	class Solution {
	public:
	    TreeNode* sortedArrayToBST(vector<int>& nums) {
	        if (nums.empty()) {
	            return nullptr;
	        }
	
	        int index = nums.size() / 2;
	        TreeNode *node = new TreeNode(nums[index]);
	        vector<int> left(nums.begin(), nums.begin() + index);
	        vector<int> right(nums.begin() + index + 1, nums.end());
	        node->left = sortedArrayToBST(left);
	        node->right = sortedArrayToBST(right);
	        return node;
	    }
	};

#### 538. 把二叉搜索树转换为累加树 ####

![](https://s3.uuu.ovh/imgs/2023/09/23/8256fc0b9a34ab9f.png)

	class Solution {
	public:
	    vector<int> path;
	    int pos;
	    void inorder(TreeNode *node) {
	        if (node == nullptr) {
	            return;
	        }
	
	        inorder(node->left);
	        path.emplace_back(node->val);
	        inorder(node->right);
	    }
	
	    void buildTree(TreeNode *node) {
	        if (node == nullptr) {
	            return;
	        }
	
	        buildTree(node->left);
	        node->val = path[pos];
	        pos++;
	        buildTree(node->right);
	    }
	
	    TreeNode* convertBST(TreeNode* root) {
	        if (root == nullptr) {
	            return nullptr;
	        }
	
	        inorder(root);
	        int sum = accumulate(path.begin(), path.end(), 0);
	        int count = 0;
	        for (int i = 0; i < path.size(); i++) {
	            int tmp = path[i];
	            path[i] = sum - count;
	            count += tmp;
	        }
	
	        pos = 0;
	        buildTree(root);
	        return root;
	    }
	};

### <a name="chapter8"></a>第八章 回溯算法

#### 77. 组合 ####

![](https://s3.uuu.ovh/imgs/2023/09/17/34ef1fa686befb3f.png)

	class Solution {
	public:
	    vector<vector<int>> result;
	    vector<int> path;
	    void backTracking(int n, int k, int start) {
	        if (path.size() == k) {
	            result.emplace_back(path);
	            return;
	        }
	
	        for (int i = start; i <= n; i++) {
	            path.emplace_back(i);
	            backTracking(n, k, i + 1);
	            path.pop_back();
	        }
	    }
	
	    vector<vector<int>> combine(int n, int k) {
	        backTracking(n, k, 1);
	        return result;
	    }
	};

#### 216. 组合总和 III ####

![](https://s3.uuu.ovh/imgs/2023/09/17/15d51fcdb8f9e1be.png)

	class Solution {
	public:
	    vector<vector<int>> result;
	    vector<int> path;
	    void backTracking(int k, int n, int start) {
	        if (path.size() == k) {
	            if (accumulate(path.begin(), path.end(), 0) == n) {
	                result.emplace_back(path);
	            }
	
	            return;
	        }
	
	        for (int i = start; i <= 9; i++) {
	            path.emplace_back(i);
	            backTracking(k, n, i + 1);
	            path.pop_back();
	        }
	    }
	    vector<vector<int>> combinationSum3(int k, int n) {
	        backTracking(k, n, 1);
	        return result;
	    }
	};

#### 17. 电话号码的字母组合 ####

![](https://s3.uuu.ovh/imgs/2023/09/24/b984417411a765b7.png)

	class Solution {
	public:
	    string path;
	    vector<string> result;
	    const string letterMap[10] = {
	        "", // 0
	        "", // 1
	        "abc", // 2
	        "def", // 3
	        "ghi", // 4
	        "jkl", // 5
	        "mno", // 6
	        "pqrs", // 7
	        "tuv", // 8
	        "wxyz", // 9
	    };
	
	    void backTracking(string digits, int start) {
	        if (digits.size() == path.size()) {
	            if (path.size() != 0) {
	                result.emplace_back(path);
	            }
	
	            return;
	        }
	
	        int number = digits[start] - '0';
	        string str = letterMap[number];
	        for (int i = 0; i < str.size(); i++) {
	            path += str[i];
	            backTracking(digits, start + 1);
	            path.pop_back();
	        }
	    }
	
	    vector<string> letterCombinations(string digits) {
	        backTracking(digits, 0);
	        return result;
	    }
	};

#### 39. 组合总和 ####

![](https://s3.uuu.ovh/imgs/2023/09/24/9bf13a1f066e5d4e.png)

	class Solution {
	public:
	    vector<vector<int>> result;
	    vector<int> path;
	    void backTracking(vector<int>& candidates, int target, int start) {
	        if (accumulate(path.begin(), path.end(), 0) == target) {
	            result.emplace_back(path);
	            return;
	        }
	
	        if (accumulate(path.begin(), path.end(), 0) > target) {
	            return;
	        }
	
	        for (int i = start; i < candidates.size(); i++) {
	            path.emplace_back(candidates[i]);
	            backTracking(candidates, target, i);
	            path.pop_back();
	        }
	    }
	
	    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
	        backTracking(candidates, target, 0);
	        return result;
	    }
	};

### <a name="chapter9"></a>第九章 贪心算法

#### 455. 分发饼干 ####

![](https://s3.uuu.ovh/imgs/2023/09/18/2b3ddc688a723a12.png)

	class Solution {
	public:
	    int findContentChildren(vector<int>& g, vector<int>& s) {
	        if (g.size() == 0 || s.size() == 0) {
	            return 0;
	        }
	
	        sort(g.begin(), g.end());
	        sort(s.begin(), s.end());
	        int gIndex = 0;
	        int sIndex = 0;
	        int result = 0;
	        while ((gIndex <= g.size() - 1) && (sIndex <= s.size() - 1)) {
	            if (s[sIndex] >= g[gIndex]) {
	                result++;
	                sIndex++;
	                gIndex++;
	            } else {
	                sIndex++;
	            }
	        }
	
	        return result;
	    }
	};


### <a name="chapter10"></a>第十章 动态规划

### <a name="chapter11"></a>第十一章 单调栈

### <a name="chapter11"></a>第十二章 图论

#### 797. 所有可能的路径 ####

![](https://s3.uuu.ovh/imgs/2023/09/24/0a8973db1d8f27fd.png)

	class Solution {
	public:
	    vector<vector<int>> result;
	    vector<int> path;
	    void dfs(vector<vector<int>>& graph, int start) {
	        if (!path.empty() && (path[path.size() - 1] == graph.size() - 1)) {
	            result.emplace_back(path);
	            return;
	        }
	
	        for (int i = 0; i < graph[start].size(); i++) {
	            path.emplace_back(graph[start][i]);
	            dfs(graph, graph[start][i]);
	            path.pop_back();
	        }
	    }
	
	    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
	        path.emplace_back(0);
	        dfs(graph, 0);
	        path.pop_back();
	        return result;
	    }
	};

#### 200. 岛屿数量 ####

![](https://s3.uuu.ovh/imgs/2023/09/26/de51109e9ae4bb1e.png)

	class Solution {
	public:
	    int result;
	    int numIslands(vector<vector<char>>& grid) {
	        result = 0;
	        if (grid.size() == 0) {
	            return result;
	        }
	
	        queue<pair<int, int>> gridQue;
	        set<pair<int, int>> isUsed;
	        for (int i = 0; i < grid.size(); i++) {
	            for (int j = 0; j < grid[0].size(); j++) {
	                if (grid[i][j] == '0' || isUsed.find({i, j}) != isUsed.end()) {
	                    continue;
	                } else {
	                    isUsed.insert({i, j});
	                    result++;
	                }
	
	                gridQue.push({i, j});
	                while (!gridQue.empty()) {
	                    int queueSize = gridQue.size();
	                    for (int k = 0; k < queueSize; k++) {
	                        pair<int, int> curGrid = gridQue.front();
	                        int row = curGrid.first;
	                        int column = curGrid.second;
	                        gridQue.pop();
	                        if (row < grid.size() - 1 && grid[row + 1][column] == '1' && isUsed.find({row + 1, column}) == isUsed.end()) {
	                            gridQue.push({row + 1, column});
	                            isUsed.insert({row + 1, column});
	                        }
	
	                        if (column < grid[0].size() - 1 && grid[row][column + 1] == '1' && isUsed.find({row, column + 1}) == isUsed.end()) {
	                            gridQue.push({row, column + 1});
	                            isUsed.insert({row, column + 1});
	                        }
	
	                        if (row > 0 && grid[row - 1][column] == '1' && isUsed.find({row - 1, column}) == isUsed.end()) {
	                            gridQue.push({row - 1, column});
	                            isUsed.insert({row - 1, column});
	                        }
	
	                        if (column > 0 && grid[row][column - 1] == '1' && isUsed.find({row, column - 1}) == isUsed.end()) {
	                            gridQue.push({row, column - 1});
	                            isUsed.insert({row, column - 1});
	                        }
	                    }
	                }
	             }
	        }
	
	        return result;
	    }
	};

### 参考资源

* [Leetcode](https://leetcode.cn/problemset/all/)
* [代码随想录](https://www.programmercarl.com/)

转载请注明：[sizheluo的博客](https://sizheluo.github.io) » [JZ_Note](https://sizheluo.github.io/2023/07/代码随想录/)