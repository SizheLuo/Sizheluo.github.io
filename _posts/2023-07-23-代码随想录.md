---
layout: post
title: "代码随想录"
date: 2023-07-23
description: "代码随想录笔记"
tag: 算法
---

### 前言

	`dmsxl算法题记录。`

### 目录

* [第一章](#chapter1)
* [第二章](#chapter2)
* [第三章](#chapter3)
* [第四章](#chapter4)
* [第五章](#chapter5)
* [第六章](#chapter6)
* [第七章](#chapter7)
* [第八章](#chapter8)
* [第九章](#chapter9)

### <a name="chapter1"></a>第一章 算法性能分析

#### 时间复杂度 ####

#### 空间复杂度 ####

### <a name="chapter2"></a>第二章 数组

#### 数组理论基础 ####

#### 704. 二分查找 ####

![](https://s3.uuu.ovh/imgs/2023/07/24/c02bdfb0df4d021e.png)

	class Solution {
	public:
	    vector<int> sortedSquares(vector<int>& nums) {
	        int i = 0;
	        int j = nums.size() - 1;
	        vector<int> result(nums.size(), 0);
	        for (int index = nums.size() - 1; index >= 0; index--) {
	            if (nums[i] * nums[i] >= nums[j] * nums[j]) {
	                result[index] = nums[i] * nums[i];
	                i++;
	            } else {
	                result[index] = nums[j] * nums[j];
	                j--;
	            }
	        }
	
	        return result;
	    }
	};

#### 27. 移除元素 ####

![](https://s3.uuu.ovh/imgs/2023/07/24/09995037a9fcb07b.png)

	class Solution {
	public:
	    int removeElement(vector<int>& nums, int val) {
	        int slowIndex = 0;
	        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
	            if (nums[fastIndex] != val) {
	                nums[slowIndex] = nums[fastIndex];
	                slowIndex++;
	            }
	        }
	
	        return slowIndex;
	    }
	};

#### 977. 有序数组的平方 ####

![](https://s3.uuu.ovh/imgs/2023/07/24/305fe87ddd3c68b3.png)

	class Solution {
	public:
	    vector<int> sortedSquares(vector<int>& nums) {
	        int i = 0;
	        int j = nums.size() - 1;
	        vector<int> result(nums.size(), 0);
	        for (int index = nums.size() - 1; index >= 0; index--) {
	            if (nums[i] * nums[i] >= nums[j] * nums[j]) {
	                result[index] = nums[i] * nums[i];
	                i++;
	            } else {
	                result[index] = nums[j] * nums[j];
	                j--;
	            }
	        }
	
	        return result;
	    }
	};

#### 209. 长度最小的子数组 ####

![](https://s3.uuu.ovh/imgs/2023/07/24/17f8f4d8e91d4eca.png)

	class Solution {
	public:
	    int minSubArrayLen(int target, vector<int>& nums) {
	        int slowIndex = 0;
	        int fastIndex = 0;
	        int sum = nums[0];
	        int length = 0;
	        while (true) {
	            if (sum >= target) {
	                if (((fastIndex - slowIndex + 1) < length || (length == 0))) {
	                    length = fastIndex - slowIndex + 1;
	                    if (length == 1) {
	                        break;
	                    }
	                }
	                
	                sum -= nums[slowIndex];
	                slowIndex++;
	            } else {
	                fastIndex++;
	                if (fastIndex >= nums.size()) {
	                    break;
	                }
	                sum += nums[fastIndex];
	            }
	        }
	
	        return length;
	    }
	};

#### 59. 螺旋矩阵 II ####

![](https://s3.uuu.ovh/imgs/2023/07/25/74d20cec0c2290d0.png)

	class Solution {
	public:
	    vector<vector<int>> generateMatrix(int n) {
	        vector<vector<int>> result(n, vector<int>(n, 0));
	        int start = 0;
	        int end = (n + 1) / 2;
	        int num = 1;
	        while (start < end) {
	            for (int i = start; i < n - start; i++) {
	                result[start][i] = num;
	                num++;
	            }
	
	            if (num >= n * n) {
	                break;
	            }
	
	            for (int i = start + 1; i < (n - 1 - start); i++) {
	                result[i][n - 1 - start] = num;
	                num++;
	            }
	
	            for (int i = n - start - 1; i >= start; i--) {
	                result[n - 1 - start][i] = num;
	                num++;
	            }
	
	            for (int i = n - start - 2; i >= start + 1; i--) {
	                result[i][start] = num;
	                num++;
	            }
	
	            start++;
	        }
	
	        return result;
	    }
	};

### <a name="chapter3"></a>第三章 链表

#### 链表理论基础 ####

#### 203. 移除链表元素 ####

![](https://s3.uuu.ovh/imgs/2023/07/29/a12e9e11fe6010e6.png)

	class Solution {
	public:
	    ListNode* removeElements(ListNode* head, int val) {
	        if (head == nullptr) {
	            return nullptr;
	        }
	
	        ListNode *dummy = new ListNode(-1, head);
	        ListNode *preNode = dummy;
	        ListNode *node = head;
	        while (node != nullptr) {
	            if (node->val == val) {
	                preNode->next = node->next;
	                ListNode *temp = node;
	                node = node->next;
	                delete temp;
	            } else {
	                preNode = node;
	                node = node->next;
	            }
	        }
	
	        return dummy->next;
	    }
	};

#### 707. 设计链表 ####

![](https://s3.bmp.ovh/imgs/2023/07/29/a70c5b6da96be23e.png)

	class MyLinkedList {
	public:
	    struct ListNode {
	        int val;
	        ListNode *next;
	        ListNode() : val(0), next(nullptr) {}
	        ListNode(int x) : val(x), next(nullptr) {}
	        ListNode(int x, ListNode *next) : val(x), next(next) {}  
	    };
	
	    ListNode *head;
	    ListNode *tail;
	    int size;
	
	    MyLinkedList() {
	        head = nullptr;
	        tail = nullptr;
	        size = 0;
	    }
	    
	    int get(int index) {
	        if (index < 0 || index >= size) {
	            return -1;
	        }
	
	        ListNode *node = head;
	        int result = node->val;
	        index--;
	        while (index >= 0 && node->next) {
	            node = node->next;
	            result = node->val;
	            index--;
	        }
	
	        return result;
	    }
	    
	    void addAtHead(int val) {
	        ListNode *node = new ListNode(val, head);
	        if (!head) {
	            head = node;
	            tail = node;
	        } else {
	            head = node;
	        }
	
	        size++;
	    }
	    
	    void addAtTail(int val) {
	        ListNode *node = new ListNode(val, nullptr);
	        if (!tail) {
	            head = node;
	            tail = node;
	        } else {
	            tail->next = node;
	            tail = node;
	        }
	
	        size++;
	    }
	    
	    void addAtIndex(int index, int val) {
	        if (index < 0 || index > size) {
	            return;
	        }
	
	        ListNode *newNode = new ListNode(val, nullptr);
	        ListNode *dummy = new ListNode(-1, head);
	        ListNode *node = head;
	        
	        if (size == 0) {
	            head = newNode;
	            tail = newNode;
	            size++;
	            return;
	        }
	
	        if (index == size) {
	            tail->next = newNode;
	            tail = newNode;
	            size++;
	            return;
	        }
	        index--;
	        while (index >= 0) {
	            index--;
	            dummy = node;
	            node = node->next;
	        }
	
	        if (dummy->val == -1) {
	            dummy->next = newNode;
	            newNode->next = node;
	            head = dummy->next;
	        } else {
	            dummy->next = newNode;
	            newNode->next = node;
	        }
	
	        size++;
	    }
	    
	    void deleteAtIndex(int index) {
	        if (index < 0 || index >= size) {
	            return;
	        } else if (size == 1) {
	            head = nullptr;
	            tail = nullptr;
	            size--;
	            return;
	        }
	
	        ListNode *dummy = new ListNode(-1, head);
	        ListNode *node = head;
	        index--;
	        while (index >= 0) {
	            index--;
	            dummy = node;
	            node = node->next;
	        }
	
	        if (dummy->val == -1) {
	            dummy->next = node->next;
	            head = dummy->next;
	        } else {
	            dummy->next = node->next;
	        }
	
	        if (!dummy->next) {
	            tail = dummy;
	        }
	
	        size--;
	        return;
	    }
	};
	
	/**
	 * Your MyLinkedList object will be instantiated and called as such:
	 * MyLinkedList* obj = new MyLinkedList();
	 * int param_1 = obj->get(index);
	 * obj->addAtHead(val);
	 * obj->addAtTail(val);
	 * obj->addAtIndex(index,val);
	 * obj->deleteAtIndex(index);
	 */

#### 206. 反转链表 ####

![](https://s3.uuu.ovh/imgs/2023/07/29/1df1f56b19a977a1.png)

	class Solution {
	public:
	    ListNode* reverseList(ListNode* head) {
	        if (head == nullptr) {
	            return nullptr;
	        }
	
	        ListNode *node = head->next;
	        ListNode *pre = head;
	        pre->next = nullptr;
	        while (node != nullptr) {
	            ListNode *temp = node;
	            node = node->next;
	            temp->next = pre;
	            pre = temp;
	        }
	
	        return pre;
	    }
	};

#### 24. 两两交换链表中的节点 ####

![](https://s3.uuu.ovh/imgs/2023/07/30/6758cf06ea1d7e68.png)

	class Solution {
	public:
	    ListNode* swapPairs(ListNode* head) {
	        if (head == nullptr) {
	            return nullptr;
	        }
	
	        ListNode *first = head;
	        ListNode *second = first->next;
	        ListNode *pre = nullptr;
	        while (first && first->next) {
	            second = first->next;
	            ListNode *tempFirst = first;
	            first = second->next;
	            second->next = tempFirst;
	            tempFirst->next = first;
	            if (pre) {
	                pre->next = second;
	            }
	
	            pre = tempFirst;
	            if (tempFirst == head) {
	                head = second;
	            }
	        }
	
	        return head;
	    }
	};

#### 19. 删除链表的倒数第 N 个结点 ####

![](https://s3.uuu.ovh/imgs/2023/08/03/11abddcb5768ebe3.png)

	class Solution {
	public:
	    ListNode* removeNthFromEnd(ListNode* head, int n) {
	        ListNode *dummy = new ListNode(-1, head);
	        ListNode *slow = dummy;
	        ListNode *fast = head;
	        while (n-- && fast) {
	            fast = fast->next;
	        }
	
	        while (fast) {
	            slow = slow->next;
	            fast = fast->next;
	        }
	
	        slow->next = slow->next->next;
	        if (slow->val == -1) {
	            head = slow->next;
	        }
	        return head;
	    }
	};

#### 面试题 02.07. 链表相交 ####

![](https://s3.uuu.ovh/imgs/2023/08/04/c7de879791de1064.png)

	class Solution {
	public:
	    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
	        int lengthA = 0;
	        int lengthB = 0;
	        ListNode *nodeA = headA;
	        ListNode *nodeB = headB;
	        while (nodeA) {
	            lengthA++;
	            nodeA = nodeA->next;
	        }
	
	        while (nodeB) {
	            lengthB++;
	            nodeB = nodeB->next;
	        }
	
	        int gap = abs(lengthA - lengthB);
	        if (lengthA >= lengthB) {
	            nodeA = headA;
	            nodeB = headB;
	        } else {
	            nodeA = headB;
	            nodeB = headA;
	        }
	
	        while (gap > 0) {
	            nodeA = nodeA->next;
	            gap--;
	        }
	
	        while (nodeA && nodeB) {
	            if (nodeA == nodeB) {
	                return nodeA;
	            }
	
	            nodeA = nodeA->next;
	            nodeB = nodeB->next;
	        }
	
	        return nullptr;
	    }
	};

#### 142. 环形链表 II ####

![](https://s3.uuu.ovh/imgs/2023/08/06/491f98449d0069e5.png)

	class Solution {
	public:
	    ListNode *detectCycle(ListNode *head) {
	        ListNode *slowNode = head;
	        ListNode *fastNode = head;
	        while (slowNode && fastNode) {
	            slowNode = slowNode->next;
	            if (!slowNode) {
	                return nullptr;
	            }
	
	            fastNode = fastNode->next;
	            if (!fastNode) {
	                return nullptr;
	            }
	
	            fastNode = fastNode->next;
	            if (!fastNode) {
	                return nullptr;
	            }
	
	            if (slowNode == fastNode) {
	                break;
	            }
	        }
	
	        slowNode = head;
	        while (slowNode != fastNode) {
	            slowNode = slowNode->next;
	            fastNode = fastNode->next;
	        }
	
	        return slowNode;
	    }
	};

### <a name="chapter4"></a>第四章 哈希表

#### 242. 有效的字母异位词 ####

![](https://s3.uuu.ovh/imgs/2023/08/07/18a6a4a7475e1382.png)

	class Solution {
	public:
	    bool isAnagram(string s, string t) {
	        unordered_map<char, int> hashMap;
	        for (int i = 0; i < s.size(); i++) {
	            hashMap[s[i]]++;
	        }
	
	        for (int i = 0; i < t.size(); i++) {
	            hashMap[t[i]]--;
	        }
	
	        for (auto iter : hashMap) {
	            if (iter.second != 0) {
	                return false;
	            }
	        }
	
	        return true;
	    }
	};

#### 349. 两个数组的交集 ####

![](https://s3.uuu.ovh/imgs/2023/08/07/227c5d97707b8c53.png)

	class Solution {
	public:
	    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
	        unordered_set<int> hashSet;
	        vector<int> result;
	        for (int i = 0; i < nums1.size(); i++) {
	            hashSet.insert(nums1[i]);
	        }
	
	        for (int i = 0; i < nums2.size(); i++) {
	            if (hashSet.find(nums2[i]) != hashSet.end()) {
	                if (find(result.begin(), result.end(), nums2[i]) == result.end()) {
	                    result.emplace_back(nums2[i]);
	                }
	            }
	        }
	
	        return result;
	    }
	};

### 参考资源

* [Leetcode](https://leetcode.cn/problemset/all/)
* [代码随想录](https://www.programmercarl.com/)

转载请注明：[sizheluo的博客](https://sizheluo.github.io) » [JZ_Note](https://sizheluo.github.io/2023/07/代码随想录/)