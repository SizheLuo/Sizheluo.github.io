---
layout: post
title: "代码随想录"
date: 2023-07-23
description: "代码随想录笔记"
tag: 算法
---

### 前言

	`dmsxl算法题记录。`

### 目录

* [第一章](#chapter1)
* [第二章](#chapter2)
* [第三章](#chapter3)
* [第四章](#chapter4)
* [第五章](#chapter5)
* [第六章](#chapter6)
* [第七章](#chapter7)
* [第八章](#chapter8)
* [第九章](#chapter9)

### <a name="chapter1"></a>第一章 算法性能分析

#### 时间复杂度 ####

#### 空间复杂度 ####

### <a name="chapter2"></a>第二章 数组

#### 数组理论基础 ####

#### 704. 二分查找 ####

![](https://s3.uuu.ovh/imgs/2023/07/24/c02bdfb0df4d021e.png)

	class Solution {
	public:
	    vector<int> sortedSquares(vector<int>& nums) {
	        int i = 0;
	        int j = nums.size() - 1;
	        vector<int> result(nums.size(), 0);
	        for (int index = nums.size() - 1; index >= 0; index--) {
	            if (nums[i] * nums[i] >= nums[j] * nums[j]) {
	                result[index] = nums[i] * nums[i];
	                i++;
	            } else {
	                result[index] = nums[j] * nums[j];
	                j--;
	            }
	        }
	
	        return result;
	    }
	};

#### 27. 移除元素 ####

![](https://s3.uuu.ovh/imgs/2023/07/24/09995037a9fcb07b.png)

	class Solution {
	public:
	    int removeElement(vector<int>& nums, int val) {
	        int slowIndex = 0;
	        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
	            if (nums[fastIndex] != val) {
	                nums[slowIndex] = nums[fastIndex];
	                slowIndex++;
	            }
	        }
	
	        return slowIndex;
	    }
	};

#### 977. 有序数组的平方 ####

![](https://s3.uuu.ovh/imgs/2023/07/24/305fe87ddd3c68b3.png)

	class Solution {
	public:
	    vector<int> sortedSquares(vector<int>& nums) {
	        int i = 0;
	        int j = nums.size() - 1;
	        vector<int> result(nums.size(), 0);
	        for (int index = nums.size() - 1; index >= 0; index--) {
	            if (nums[i] * nums[i] >= nums[j] * nums[j]) {
	                result[index] = nums[i] * nums[i];
	                i++;
	            } else {
	                result[index] = nums[j] * nums[j];
	                j--;
	            }
	        }
	
	        return result;
	    }
	};

#### 209. 长度最小的子数组 ####

![](https://s3.uuu.ovh/imgs/2023/07/24/17f8f4d8e91d4eca.png)

	class Solution {
	public:
	    int minSubArrayLen(int target, vector<int>& nums) {
	        int slowIndex = 0;
	        int fastIndex = 0;
	        int sum = nums[0];
	        int length = 0;
	        while (true) {
	            if (sum >= target) {
	                if (((fastIndex - slowIndex + 1) < length || (length == 0))) {
	                    length = fastIndex - slowIndex + 1;
	                    if (length == 1) {
	                        break;
	                    }
	                }
	                
	                sum -= nums[slowIndex];
	                slowIndex++;
	            } else {
	                fastIndex++;
	                if (fastIndex >= nums.size()) {
	                    break;
	                }
	                sum += nums[fastIndex];
	            }
	        }
	
	        return length;
	    }
	};

#### 59. 螺旋矩阵 II ####

![](https://s3.uuu.ovh/imgs/2023/07/25/74d20cec0c2290d0.png)

	class Solution {
	public:
	    vector<vector<int>> generateMatrix(int n) {
	        vector<vector<int>> result(n, vector<int>(n, 0));
	        int start = 0;
	        int end = (n + 1) / 2;
	        int num = 1;
	        while (start < end) {
	            for (int i = start; i < n - start; i++) {
	                result[start][i] = num;
	                num++;
	            }
	
	            if (num >= n * n) {
	                break;
	            }
	
	            for (int i = start + 1; i < (n - 1 - start); i++) {
	                result[i][n - 1 - start] = num;
	                num++;
	            }
	
	            for (int i = n - start - 1; i >= start; i--) {
	                result[n - 1 - start][i] = num;
	                num++;
	            }
	
	            for (int i = n - start - 2; i >= start + 1; i--) {
	                result[i][start] = num;
	                num++;
	            }
	
	            start++;
	        }
	
	        return result;
	    }
	};

### <a name="chapter3"></a>第三章 链表

#### 链表理论基础 ####

#### 203. 移除链表元素 ####

![](https://s3.uuu.ovh/imgs/2023/07/29/a12e9e11fe6010e6.png)

	class Solution {
	public:
	    ListNode* removeElements(ListNode* head, int val) {
	        if (head == nullptr) {
	            return nullptr;
	        }
	
	        ListNode *dummy = new ListNode(-1, head);
	        ListNode *preNode = dummy;
	        ListNode *node = head;
	        while (node != nullptr) {
	            if (node->val == val) {
	                preNode->next = node->next;
	                ListNode *temp = node;
	                node = node->next;
	                delete temp;
	            } else {
	                preNode = node;
	                node = node->next;
	            }
	        }
	
	        return dummy->next;
	    }
	};

#### 707. 设计链表 ####

![](https://s3.bmp.ovh/imgs/2023/07/29/a70c5b6da96be23e.png)

	class MyLinkedList {
	public:
	    struct ListNode {
	        int val;
	        ListNode *next;
	        ListNode() : val(0), next(nullptr) {}
	        ListNode(int x) : val(x), next(nullptr) {}
	        ListNode(int x, ListNode *next) : val(x), next(next) {}  
	    };
	
	    ListNode *head;
	    ListNode *tail;
	    int size;
	
	    MyLinkedList() {
	        head = nullptr;
	        tail = nullptr;
	        size = 0;
	    }
	    
	    int get(int index) {
	        if (index < 0 || index >= size) {
	            return -1;
	        }
	
	        ListNode *node = head;
	        int result = node->val;
	        index--;
	        while (index >= 0 && node->next) {
	            node = node->next;
	            result = node->val;
	            index--;
	        }
	
	        return result;
	    }
	    
	    void addAtHead(int val) {
	        ListNode *node = new ListNode(val, head);
	        if (!head) {
	            head = node;
	            tail = node;
	        } else {
	            head = node;
	        }
	
	        size++;
	    }
	    
	    void addAtTail(int val) {
	        ListNode *node = new ListNode(val, nullptr);
	        if (!tail) {
	            head = node;
	            tail = node;
	        } else {
	            tail->next = node;
	            tail = node;
	        }
	
	        size++;
	    }
	    
	    void addAtIndex(int index, int val) {
	        if (index < 0 || index > size) {
	            return;
	        }
	
	        ListNode *newNode = new ListNode(val, nullptr);
	        ListNode *dummy = new ListNode(-1, head);
	        ListNode *node = head;
	        
	        if (size == 0) {
	            head = newNode;
	            tail = newNode;
	            size++;
	            return;
	        }
	
	        if (index == size) {
	            tail->next = newNode;
	            tail = newNode;
	            size++;
	            return;
	        }
	        index--;
	        while (index >= 0) {
	            index--;
	            dummy = node;
	            node = node->next;
	        }
	
	        if (dummy->val == -1) {
	            dummy->next = newNode;
	            newNode->next = node;
	            head = dummy->next;
	        } else {
	            dummy->next = newNode;
	            newNode->next = node;
	        }
	
	        size++;
	    }
	    
	    void deleteAtIndex(int index) {
	        if (index < 0 || index >= size) {
	            return;
	        } else if (size == 1) {
	            head = nullptr;
	            tail = nullptr;
	            size--;
	            return;
	        }
	
	        ListNode *dummy = new ListNode(-1, head);
	        ListNode *node = head;
	        index--;
	        while (index >= 0) {
	            index--;
	            dummy = node;
	            node = node->next;
	        }
	
	        if (dummy->val == -1) {
	            dummy->next = node->next;
	            head = dummy->next;
	        } else {
	            dummy->next = node->next;
	        }
	
	        if (!dummy->next) {
	            tail = dummy;
	        }
	
	        size--;
	        return;
	    }
	};
	
	/**
	 * Your MyLinkedList object will be instantiated and called as such:
	 * MyLinkedList* obj = new MyLinkedList();
	 * int param_1 = obj->get(index);
	 * obj->addAtHead(val);
	 * obj->addAtTail(val);
	 * obj->addAtIndex(index,val);
	 * obj->deleteAtIndex(index);
	 */

#### 206. 反转链表 ####

![](https://s3.uuu.ovh/imgs/2023/07/29/1df1f56b19a977a1.png)

	class Solution {
	public:
	    ListNode* reverseList(ListNode* head) {
	        if (head == nullptr) {
	            return nullptr;
	        }
	
	        ListNode *node = head->next;
	        ListNode *pre = head;
	        pre->next = nullptr;
	        while (node != nullptr) {
	            ListNode *temp = node;
	            node = node->next;
	            temp->next = pre;
	            pre = temp;
	        }
	
	        return pre;
	    }
	};

#### 24. 两两交换链表中的节点 ####

![](https://s3.uuu.ovh/imgs/2023/07/30/6758cf06ea1d7e68.png)

	class Solution {
	public:
	    ListNode* swapPairs(ListNode* head) {
	        if (head == nullptr) {
	            return nullptr;
	        }
	
	        ListNode *first = head;
	        ListNode *second = first->next;
	        ListNode *pre = nullptr;
	        while (first && first->next) {
	            second = first->next;
	            ListNode *tempFirst = first;
	            first = second->next;
	            second->next = tempFirst;
	            tempFirst->next = first;
	            if (pre) {
	                pre->next = second;
	            }
	
	            pre = tempFirst;
	            if (tempFirst == head) {
	                head = second;
	            }
	        }
	
	        return head;
	    }
	};

#### 19. 删除链表的倒数第 N 个结点 ####

![](https://s3.uuu.ovh/imgs/2023/08/03/11abddcb5768ebe3.png)

	class Solution {
	public:
	    ListNode* removeNthFromEnd(ListNode* head, int n) {
	        ListNode *dummy = new ListNode(-1, head);
	        ListNode *slow = dummy;
	        ListNode *fast = head;
	        while (n-- && fast) {
	            fast = fast->next;
	        }
	
	        while (fast) {
	            slow = slow->next;
	            fast = fast->next;
	        }
	
	        slow->next = slow->next->next;
	        if (slow->val == -1) {
	            head = slow->next;
	        }
	        return head;
	    }
	};

#### 面试题 02.07. 链表相交 ####

![](https://s3.uuu.ovh/imgs/2023/08/04/c7de879791de1064.png)

	class Solution {
	public:
	    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
	        int lengthA = 0;
	        int lengthB = 0;
	        ListNode *nodeA = headA;
	        ListNode *nodeB = headB;
	        while (nodeA) {
	            lengthA++;
	            nodeA = nodeA->next;
	        }
	
	        while (nodeB) {
	            lengthB++;
	            nodeB = nodeB->next;
	        }
	
	        int gap = abs(lengthA - lengthB);
	        if (lengthA >= lengthB) {
	            nodeA = headA;
	            nodeB = headB;
	        } else {
	            nodeA = headB;
	            nodeB = headA;
	        }
	
	        while (gap > 0) {
	            nodeA = nodeA->next;
	            gap--;
	        }
	
	        while (nodeA && nodeB) {
	            if (nodeA == nodeB) {
	                return nodeA;
	            }
	
	            nodeA = nodeA->next;
	            nodeB = nodeB->next;
	        }
	
	        return nullptr;
	    }
	};

#### 142. 环形链表 II ####

![](https://s3.uuu.ovh/imgs/2023/08/06/491f98449d0069e5.png)

	class Solution {
	public:
	    ListNode *detectCycle(ListNode *head) {
	        ListNode *slowNode = head;
	        ListNode *fastNode = head;
	        while (slowNode && fastNode) {
	            slowNode = slowNode->next;
	            if (!slowNode) {
	                return nullptr;
	            }
	
	            fastNode = fastNode->next;
	            if (!fastNode) {
	                return nullptr;
	            }
	
	            fastNode = fastNode->next;
	            if (!fastNode) {
	                return nullptr;
	            }
	
	            if (slowNode == fastNode) {
	                break;
	            }
	        }
	
	        slowNode = head;
	        while (slowNode != fastNode) {
	            slowNode = slowNode->next;
	            fastNode = fastNode->next;
	        }
	
	        return slowNode;
	    }
	};

### <a name="chapter4"></a>第四章 哈希表

#### 242. 有效的字母异位词 ####

![](https://s3.uuu.ovh/imgs/2023/08/07/18a6a4a7475e1382.png)

	class Solution {
	public:
	    bool isAnagram(string s, string t) {
	        unordered_map<char, int> hashMap;
	        for (int i = 0; i < s.size(); i++) {
	            hashMap[s[i]]++;
	        }
	
	        for (int i = 0; i < t.size(); i++) {
	            hashMap[t[i]]--;
	        }
	
	        for (auto iter : hashMap) {
	            if (iter.second != 0) {
	                return false;
	            }
	        }
	
	        return true;
	    }
	};

#### 349. 两个数组的交集 ####

![](https://s3.uuu.ovh/imgs/2023/08/07/227c5d97707b8c53.png)

	class Solution {
	public:
	    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
	        unordered_set<int> hashSet;
	        vector<int> result;
	        for (int i = 0; i < nums1.size(); i++) {
	            hashSet.insert(nums1[i]);
	        }
	
	        for (int i = 0; i < nums2.size(); i++) {
	            if (hashSet.find(nums2[i]) != hashSet.end()) {
	                if (find(result.begin(), result.end(), nums2[i]) == result.end()) {
	                    result.emplace_back(nums2[i]);
	                }
	            }
	        }
	
	        return result;
	    }
	};

#### 202. 快乐数 ####

![](https://s3.uuu.ovh/imgs/2023/08/09/0e5641406295f73d.png)

	class Solution {
	public:
	    bool isHappy(int n) {
	        unordered_set<int> nums;
	        int num = n;
	        while (true) {
	            int sNum = 0;
	            while (num > 0) {
	                int single = num % 10;
	                num = num / 10;
	                sNum += single *single;
	            }
	
	            num = sNum;
	            if (nums.find(sNum) != nums.end()) {
	                return false;
	            }
	
	            if (sNum == 1) {
	                return true;
	            }
	
	            nums.insert(sNum);
	        }
	
	        return true;
	    }
	};

#### 1. 两数之和 ####

![](https://s3.uuu.ovh/imgs/2023/08/13/9dbab8ab9b4dc436.png)

	class Solution {
	public:
	    vector<int> twoSum(vector<int>& nums, int target) {
	        unordered_map<int, int> hashMap;
	        for (int i = 0; i < nums.size(); i++) {
	            auto iter = hashMap.find(target - nums[i]);
	            if (iter != hashMap.end()) {
	                return {i, iter->second};
	            }
	
	            hashMap.insert(pair<int, int>(nums[i], i));
	        }
	
	        return {};
	    }
	};

#### 454. 四数相加 II ####

![](https://s3.uuu.ovh/imgs/2023/08/13/b6901fbc7f2c6a18.png)

	class Solution {
	public:
	    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
	        int result = 0;
	        unordered_map<int, int> hashMap;
	        for (int i = 0; i < nums1.size(); i++) {
	            for (int j = 0; j < nums2.size(); j++) {
	                hashMap[nums1[i] + nums2[j]]++;
	            }
	        }
	
	        for (int i = 0; i < nums3.size(); i++) {
	            for (int j = 0; j < nums4.size(); j++) {
	                int num = -(nums3[i] + nums4[j]);
	                if (hashMap.find(num) != hashMap.end()) {
	                    result += hashMap[num];
	                }
	            }
	        }
	
	        return result;
	    }
	};

#### 383. 赎金信 ####

![](https://s3.uuu.ovh/imgs/2023/08/15/bb5e7d3baf1b3362.png)

	class Solution {
	public:
	    bool canConstruct(string ransomNote, string magazine) {
	        unordered_map<int, int> hashMap;
	        for (int i = 0; i < magazine.size(); i++) {
	            hashMap[magazine[i]]++;
	        }
	
	        for (int i = 0; i < ransomNote.size(); i++) {
	            auto iter = hashMap.find(ransomNote[i]);
	            if (iter == hashMap.end() || iter->second <= 0) {
	                return false;
	            }
	
	            iter->second--;
	        }
	
	        return true;
	    }
	};

#### 15. 三数之和 ####

![](https://s3.uuu.ovh/imgs/2023/08/22/8b19bb45c4418ade.png)

	class Solution {
	public:
	    vector<vector<int>> threeSum(vector<int>& nums) {
	        vector<vector<int>> result;
	        sort(nums.begin(), nums.end());
	        for (int i = 0; i < nums.size(); i++) {
	            if (nums[i] > 0) {
	                return result;
	            }
	
	            if (i > 0 && nums[i] == nums[i - 1]) {
	                continue;
	            }
	
	            int left = i + 1;
	            int right = nums.size() - 1;
	            while (left < right) {
	                if (nums[i] + nums[left] + nums[right] == 0) {
	                    result.emplace_back(vector<int>{nums[i], nums[left], nums[right]});
	                    while (left + 1 < nums.size() && nums[left] == nums[left + 1]) {
	                        left++;
	                    }
	
	                    while (right - 1 >= 0 && nums[right] == nums[right - 1]) {
	                        right--;
	                    }
	
	                    left++;
	                    right--;
	                } else if (nums[i] + nums[left] + nums[right] > 0) {
	                    right--;
	                } else {
	                    left++;
	                }
	            }
	        }
	
	        return result;
	    }
	};

#### 18. 四数之和 ####

![](https://s3.uuu.ovh/imgs/2023/08/23/ab0b0dc1954cb6d2.png)

	class Solution {
	public:
	    vector<vector<int>> fourSum(vector<int>& nums, int target) {
	        vector<vector<int>> result;
	        sort(nums.begin(), nums.end());
	        for (int i = 0; i < nums.size(); i++) {
	            if (i > 0 && nums[i] == nums[i - 1]) {
	                continue;
	            }
	
	            for (int j = i + 1; j < nums.size(); j++) {
	                if (j > i + 1 && nums[j] == nums[j - 1]) {
	                    continue;
	                }
	
	                int left = j + 1;
	                int right = nums.size() - 1;
	                while (left < right) {
	                    if ((long)nums[i] + nums[j] + nums[left] + nums[right] > target) {
	                        right--;
	                    } else if ((long)nums[i] + nums[j] + nums[left] + nums[right] < target) {
	                        left++;
	                    } else {
	                        result.emplace_back(vector<int>{nums[i], nums[j], nums[left], nums[right]});
	                        while (left < right && nums[left] == nums[left + 1]) left++;
	                        while (left < right && nums[right] == nums[right - 1]) right--;
	                        left++;
	                        right--;
	                    }
	                }
	            }
	        }
	
	        return result;
	    }
	};

### <a name="chapter4"></a>第五章 字符串

#### 344. 反转字符串 ####

![](https://s3.uuu.ovh/imgs/2023/08/23/7f4b5cb3d35526e7.png)

	class Solution {
	public:
	    void reverseString(vector<char>& s) {
	        int left = 0;
	        int right = s.size() - 1;
	        while (left < right) {
	            char tmp = s[left];
	            s[left] = s[right];
	            s[right] = tmp;
	            left++;
	            right--;
	        }
	    }
	};

#### 541. 反转字符串 II ####

![](https://s3.uuu.ovh/imgs/2023/08/23/ecfd63eb2a720a70.png)

	class Solution {
	public:
	    string reverseStr(string s, int k) {
	        int pos = 0;
	        for (int i = 2 * k - 1; i < s.size(); i += 2 *k) {
	            reverse(s.begin() + pos, s.begin() + pos + k);
	            pos = i + 1;
	        }
	
	        if (s.size() - pos > k) {
	            reverse(s.begin() + pos, s.begin() + pos + k);
	        } else {
	            reverse(s.begin() + pos, s.end());
	        }
	
	        return s;
	    }
	};

#### 剑指 Offer 05. 替换空格 ####

![](https://s3.uuu.ovh/imgs/2023/08/23/3219b9c29daf3940.png)

	class Solution {
	public:
	    string replaceSpace(string s) {
	        int left = s.size() - 1;
	        int spaceNum = 0;
	        for (int i = 0; i < s.size(); i++) {
	            if (s[i] == ' ') {
	                spaceNum++;
	            }
	        }
	
	        s.resize(left + 1 + 2 * spaceNum);
	        int right = s.size() - 1;
	        while (left >= 0) {
	            if (s[left] != ' ') {
	                s[right--] = s[left--];
	            } else {
	                s[right--] = '0';
	                s[right--] = '2';
	                s[right--] = '%';
	                left--;
	            }
	        }
	
	        return s;
	    }
	};

#### 151. 反转字符串中的单词 ####

![](https://s3.uuu.ovh/imgs/2023/08/25/cc62a0df1541fc5c.png)

	class Solution {
	public:
	    string reverseWords(string s) {
	        int slow = 0; 
	        for (int i = 0; i < s.size(); ++i) {
	            if (s[i] != ' ') {
	                if (slow != 0) s[slow++] = ' ';
	                while (i < s.size() && s[i] != ' ') {
	                    s[slow++] = s[i++];
	                }
	            }
	        }
	        s.resize(slow);
	
	        int pos = 0;
	        int valid = 0;
	        string result = "";
	        for (int i = 0; i < s.size(); i++) {
	            if (s[i] == ' ') {
	                reverse(s.begin() + pos, s.begin() + i);
	                pos = i + 1;
	                valid = 0;
	            }
	        }
	
	        reverse(s.begin() + pos, s.end());
	        reverse(s.begin(), s.end());
	        return s;
	    }
	};

#### 剑指 Offer 58 - II. 左旋转字符串 ####

![](https://s3.uuu.ovh/imgs/2023/08/25/660ad836f3ec9e52.png)

	class Solution {
	public:
	    string reverseLeftWords(string s, int n) {
	        reverse(s.begin(), s.end());
	        reverse(s.begin(), s.begin() + s.size() - n);
	        reverse(s.begin() + s.size() -n, s.end());
	        return s;
	    }
	};

#### 28. 找出字符串中第一个匹配项的下标 ####

![](https://s3.uuu.ovh/imgs/2023/08/26/6e09fbeb4ff08672.png)

	class Solution {
	public:
	    int strStr(string haystack, string needle) {
	        if (needle.size() > haystack.size()) {
	            return -1;
	        }
	
	        int j = 0;
	        for (int i = 0; i < haystack.size() - needle.size() + 1; i++) {
	            int index = i;
	            for (j = 0; j < needle.size(); j++) {
	                if (haystack[index] == needle[j]) {
	                    index++;
	                    continue;
	                }
	
	                break;
	            }
	
	            if (j == needle.size()) {
	                return i;
	            }
	        }
	
	        return -1;
	    }
	};

### 参考资源

* [Leetcode](https://leetcode.cn/problemset/all/)
* [代码随想录](https://www.programmercarl.com/)

转载请注明：[sizheluo的博客](https://sizheluo.github.io) » [JZ_Note](https://sizheluo.github.io/2023/07/代码随想录/)