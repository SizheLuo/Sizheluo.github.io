---
layout: post
title: "代码随想录"
date: 2023-07-23
description: "代码随想录笔记"
tag: 算法
---

### 前言

	`dmsxl算法题记录。`

### 目录

* [第一章](#chapter1)
* [第二章](#chapter2)
* [第三章](#chapter3)
* [第四章](#chapter4)
* [第五章](#chapter5)
* [第六章](#chapter6)
* [第七章](#chapter7)
* [第八章](#chapter8)
* [第九章](#chapter9)

### <a name="chapter1"></a>第一章 算法性能分析

#### 时间复杂度 ####

#### 空间复杂度 ####

### <a name="chapter2"></a>第二章 数组

#### 数组理论基础 ####

#### 704. 二分查找 ####

![](https://s3.uuu.ovh/imgs/2023/07/24/c02bdfb0df4d021e.png)

	class Solution {
	public:
	    vector<int> sortedSquares(vector<int>& nums) {
	        int i = 0;
	        int j = nums.size() - 1;
	        vector<int> result(nums.size(), 0);
	        for (int index = nums.size() - 1; index >= 0; index--) {
	            if (nums[i] * nums[i] >= nums[j] * nums[j]) {
	                result[index] = nums[i] * nums[i];
	                i++;
	            } else {
	                result[index] = nums[j] * nums[j];
	                j--;
	            }
	        }
	
	        return result;
	    }
	};

#### 27. 移除元素 ####

![](https://s3.uuu.ovh/imgs/2023/07/24/09995037a9fcb07b.png)

	class Solution {
	public:
	    int removeElement(vector<int>& nums, int val) {
	        int slowIndex = 0;
	        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
	            if (nums[fastIndex] != val) {
	                nums[slowIndex] = nums[fastIndex];
	                slowIndex++;
	            }
	        }
	
	        return slowIndex;
	    }
	};

#### 977. 有序数组的平方 ####

![](https://s3.uuu.ovh/imgs/2023/07/24/305fe87ddd3c68b3.png)

	class Solution {
	public:
	    vector<int> sortedSquares(vector<int>& nums) {
	        int i = 0;
	        int j = nums.size() - 1;
	        vector<int> result(nums.size(), 0);
	        for (int index = nums.size() - 1; index >= 0; index--) {
	            if (nums[i] * nums[i] >= nums[j] * nums[j]) {
	                result[index] = nums[i] * nums[i];
	                i++;
	            } else {
	                result[index] = nums[j] * nums[j];
	                j--;
	            }
	        }
	
	        return result;
	    }
	};

#### 209. 长度最小的子数组 ####

![](https://s3.uuu.ovh/imgs/2023/07/24/17f8f4d8e91d4eca.png)

	class Solution {
	public:
	    int minSubArrayLen(int target, vector<int>& nums) {
	        int slowIndex = 0;
	        int fastIndex = 0;
	        int sum = nums[0];
	        int length = 0;
	        while (true) {
	            if (sum >= target) {
	                if (((fastIndex - slowIndex + 1) < length || (length == 0))) {
	                    length = fastIndex - slowIndex + 1;
	                    if (length == 1) {
	                        break;
	                    }
	                }
	                
	                sum -= nums[slowIndex];
	                slowIndex++;
	            } else {
	                fastIndex++;
	                if (fastIndex >= nums.size()) {
	                    break;
	                }
	                sum += nums[fastIndex];
	            }
	        }
	
	        return length;
	    }
	};

#### 59. 螺旋矩阵 II ####

![](https://s3.uuu.ovh/imgs/2023/07/25/74d20cec0c2290d0.png)

	class Solution {
	public:
	    vector<vector<int>> generateMatrix(int n) {
	        vector<vector<int>> result(n, vector<int>(n, 0));
	        int start = 0;
	        int end = (n + 1) / 2;
	        int num = 1;
	        while (start < end) {
	            for (int i = start; i < n - start; i++) {
	                result[start][i] = num;
	                num++;
	            }
	
	            if (num >= n * n) {
	                break;
	            }
	
	            for (int i = start + 1; i < (n - 1 - start); i++) {
	                result[i][n - 1 - start] = num;
	                num++;
	            }
	
	            for (int i = n - start - 1; i >= start; i--) {
	                result[n - 1 - start][i] = num;
	                num++;
	            }
	
	            for (int i = n - start - 2; i >= start + 1; i--) {
	                result[i][start] = num;
	                num++;
	            }
	
	            start++;
	        }
	
	        return result;
	    }
	};

### <a name="chapter3"></a>第三章 链表

#### 链表理论基础 ####

#### 203. 移除链表元素 ####

![](https://s3.uuu.ovh/imgs/2023/07/29/a12e9e11fe6010e6.png)

	class Solution {
	public:
	    ListNode* removeElements(ListNode* head, int val) {
	        if (head == nullptr) {
	            return nullptr;
	        }
	
	        ListNode *dummy = new ListNode(-1, head);
	        ListNode *preNode = dummy;
	        ListNode *node = head;
	        while (node != nullptr) {
	            if (node->val == val) {
	                preNode->next = node->next;
	                ListNode *temp = node;
	                node = node->next;
	                delete temp;
	            } else {
	                preNode = node;
	                node = node->next;
	            }
	        }
	
	        return dummy->next;
	    }
	};

#### 707. 设计链表 ####

![](https://s3.bmp.ovh/imgs/2023/07/29/a70c5b6da96be23e.png)

	class MyLinkedList {
	public:
	    struct ListNode {
	        int val;
	        ListNode *next;
	        ListNode() : val(0), next(nullptr) {}
	        ListNode(int x) : val(x), next(nullptr) {}
	        ListNode(int x, ListNode *next) : val(x), next(next) {}  
	    };
	
	    ListNode *head;
	    ListNode *tail;
	    int size;
	
	    MyLinkedList() {
	        head = nullptr;
	        tail = nullptr;
	        size = 0;
	    }
	    
	    int get(int index) {
	        if (index < 0 || index >= size) {
	            return -1;
	        }
	
	        ListNode *node = head;
	        int result = node->val;
	        index--;
	        while (index >= 0 && node->next) {
	            node = node->next;
	            result = node->val;
	            index--;
	        }
	
	        return result;
	    }
	    
	    void addAtHead(int val) {
	        ListNode *node = new ListNode(val, head);
	        if (!head) {
	            head = node;
	            tail = node;
	        } else {
	            head = node;
	        }
	
	        size++;
	    }
	    
	    void addAtTail(int val) {
	        ListNode *node = new ListNode(val, nullptr);
	        if (!tail) {
	            head = node;
	            tail = node;
	        } else {
	            tail->next = node;
	            tail = node;
	        }
	
	        size++;
	    }
	    
	    void addAtIndex(int index, int val) {
	        if (index < 0 || index > size) {
	            return;
	        }
	
	        ListNode *newNode = new ListNode(val, nullptr);
	        ListNode *dummy = new ListNode(-1, head);
	        ListNode *node = head;
	        
	        if (size == 0) {
	            head = newNode;
	            tail = newNode;
	            size++;
	            return;
	        }
	
	        if (index == size) {
	            tail->next = newNode;
	            tail = newNode;
	            size++;
	            return;
	        }
	        index--;
	        while (index >= 0) {
	            index--;
	            dummy = node;
	            node = node->next;
	        }
	
	        if (dummy->val == -1) {
	            dummy->next = newNode;
	            newNode->next = node;
	            head = dummy->next;
	        } else {
	            dummy->next = newNode;
	            newNode->next = node;
	        }
	
	        size++;
	    }
	    
	    void deleteAtIndex(int index) {
	        if (index < 0 || index >= size) {
	            return;
	        } else if (size == 1) {
	            head = nullptr;
	            tail = nullptr;
	            size--;
	            return;
	        }
	
	        ListNode *dummy = new ListNode(-1, head);
	        ListNode *node = head;
	        index--;
	        while (index >= 0) {
	            index--;
	            dummy = node;
	            node = node->next;
	        }
	
	        if (dummy->val == -1) {
	            dummy->next = node->next;
	            head = dummy->next;
	        } else {
	            dummy->next = node->next;
	        }
	
	        if (!dummy->next) {
	            tail = dummy;
	        }
	
	        size--;
	        return;
	    }
	};
	
	/**
	 * Your MyLinkedList object will be instantiated and called as such:
	 * MyLinkedList* obj = new MyLinkedList();
	 * int param_1 = obj->get(index);
	 * obj->addAtHead(val);
	 * obj->addAtTail(val);
	 * obj->addAtIndex(index,val);
	 * obj->deleteAtIndex(index);
	 */

#### 206. 反转链表 ####

![](https://s3.uuu.ovh/imgs/2023/07/29/1df1f56b19a977a1.png)

	class Solution {
	public:
	    ListNode* reverseList(ListNode* head) {
	        if (head == nullptr) {
	            return nullptr;
	        }
	
	        ListNode *node = head->next;
	        ListNode *pre = head;
	        pre->next = nullptr;
	        while (node != nullptr) {
	            ListNode *temp = node;
	            node = node->next;
	            temp->next = pre;
	            pre = temp;
	        }
	
	        return pre;
	    }
	};

#### 24. 两两交换链表中的节点 ####

![](https://s3.uuu.ovh/imgs/2023/07/30/6758cf06ea1d7e68.png)

	class Solution {
	public:
	    ListNode* swapPairs(ListNode* head) {
	        if (head == nullptr) {
	            return nullptr;
	        }
	
	        ListNode *first = head;
	        ListNode *second = first->next;
	        ListNode *pre = nullptr;
	        while (first && first->next) {
	            second = first->next;
	            ListNode *tempFirst = first;
	            first = second->next;
	            second->next = tempFirst;
	            tempFirst->next = first;
	            if (pre) {
	                pre->next = second;
	            }
	
	            pre = tempFirst;
	            if (tempFirst == head) {
	                head = second;
	            }
	        }
	
	        return head;
	    }
	};

#### 19. 删除链表的倒数第 N 个结点 ####

![](https://s3.uuu.ovh/imgs/2023/08/03/11abddcb5768ebe3.png)

	class Solution {
	public:
	    ListNode* removeNthFromEnd(ListNode* head, int n) {
	        ListNode *dummy = new ListNode(-1, head);
	        ListNode *slow = dummy;
	        ListNode *fast = head;
	        while (n-- && fast) {
	            fast = fast->next;
	        }
	
	        while (fast) {
	            slow = slow->next;
	            fast = fast->next;
	        }
	
	        slow->next = slow->next->next;
	        if (slow->val == -1) {
	            head = slow->next;
	        }
	        return head;
	    }
	};

#### 面试题 02.07. 链表相交 ####

![](https://s3.uuu.ovh/imgs/2023/08/04/c7de879791de1064.png)

	class Solution {
	public:
	    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
	        int lengthA = 0;
	        int lengthB = 0;
	        ListNode *nodeA = headA;
	        ListNode *nodeB = headB;
	        while (nodeA) {
	            lengthA++;
	            nodeA = nodeA->next;
	        }
	
	        while (nodeB) {
	            lengthB++;
	            nodeB = nodeB->next;
	        }
	
	        int gap = abs(lengthA - lengthB);
	        if (lengthA >= lengthB) {
	            nodeA = headA;
	            nodeB = headB;
	        } else {
	            nodeA = headB;
	            nodeB = headA;
	        }
	
	        while (gap > 0) {
	            nodeA = nodeA->next;
	            gap--;
	        }
	
	        while (nodeA && nodeB) {
	            if (nodeA == nodeB) {
	                return nodeA;
	            }
	
	            nodeA = nodeA->next;
	            nodeB = nodeB->next;
	        }
	
	        return nullptr;
	    }
	};

#### 142. 环形链表 II ####

![](https://s3.uuu.ovh/imgs/2023/08/06/491f98449d0069e5.png)

	class Solution {
	public:
	    ListNode *detectCycle(ListNode *head) {
	        ListNode *slowNode = head;
	        ListNode *fastNode = head;
	        while (slowNode && fastNode) {
	            slowNode = slowNode->next;
	            if (!slowNode) {
	                return nullptr;
	            }
	
	            fastNode = fastNode->next;
	            if (!fastNode) {
	                return nullptr;
	            }
	
	            fastNode = fastNode->next;
	            if (!fastNode) {
	                return nullptr;
	            }
	
	            if (slowNode == fastNode) {
	                break;
	            }
	        }
	
	        slowNode = head;
	        while (slowNode != fastNode) {
	            slowNode = slowNode->next;
	            fastNode = fastNode->next;
	        }
	
	        return slowNode;
	    }
	};

### <a name="chapter4"></a>第四章 哈希表

#### 242. 有效的字母异位词 ####

![](https://s3.uuu.ovh/imgs/2023/08/07/18a6a4a7475e1382.png)

	class Solution {
	public:
	    bool isAnagram(string s, string t) {
	        unordered_map<char, int> hashMap;
	        for (int i = 0; i < s.size(); i++) {
	            hashMap[s[i]]++;
	        }
	
	        for (int i = 0; i < t.size(); i++) {
	            hashMap[t[i]]--;
	        }
	
	        for (auto iter : hashMap) {
	            if (iter.second != 0) {
	                return false;
	            }
	        }
	
	        return true;
	    }
	};

#### 349. 两个数组的交集 ####

![](https://s3.uuu.ovh/imgs/2023/08/07/227c5d97707b8c53.png)

	class Solution {
	public:
	    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
	        unordered_set<int> hashSet;
	        vector<int> result;
	        for (int i = 0; i < nums1.size(); i++) {
	            hashSet.insert(nums1[i]);
	        }
	
	        for (int i = 0; i < nums2.size(); i++) {
	            if (hashSet.find(nums2[i]) != hashSet.end()) {
	                if (find(result.begin(), result.end(), nums2[i]) == result.end()) {
	                    result.emplace_back(nums2[i]);
	                }
	            }
	        }
	
	        return result;
	    }
	};

#### 202. 快乐数 ####

![](https://s3.uuu.ovh/imgs/2023/08/09/0e5641406295f73d.png)

	class Solution {
	public:
	    bool isHappy(int n) {
	        unordered_set<int> nums;
	        int num = n;
	        while (true) {
	            int sNum = 0;
	            while (num > 0) {
	                int single = num % 10;
	                num = num / 10;
	                sNum += single *single;
	            }
	
	            num = sNum;
	            if (nums.find(sNum) != nums.end()) {
	                return false;
	            }
	
	            if (sNum == 1) {
	                return true;
	            }
	
	            nums.insert(sNum);
	        }
	
	        return true;
	    }
	};

#### 1. 两数之和 ####

![](https://s3.uuu.ovh/imgs/2023/08/13/9dbab8ab9b4dc436.png)

	class Solution {
	public:
	    vector<int> twoSum(vector<int>& nums, int target) {
	        unordered_map<int, int> hashMap;
	        for (int i = 0; i < nums.size(); i++) {
	            auto iter = hashMap.find(target - nums[i]);
	            if (iter != hashMap.end()) {
	                return {i, iter->second};
	            }
	
	            hashMap.insert(pair<int, int>(nums[i], i));
	        }
	
	        return {};
	    }
	};

#### 454. 四数相加 II ####

![](https://s3.uuu.ovh/imgs/2023/08/13/b6901fbc7f2c6a18.png)

	class Solution {
	public:
	    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
	        int result = 0;
	        unordered_map<int, int> hashMap;
	        for (int i = 0; i < nums1.size(); i++) {
	            for (int j = 0; j < nums2.size(); j++) {
	                hashMap[nums1[i] + nums2[j]]++;
	            }
	        }
	
	        for (int i = 0; i < nums3.size(); i++) {
	            for (int j = 0; j < nums4.size(); j++) {
	                int num = -(nums3[i] + nums4[j]);
	                if (hashMap.find(num) != hashMap.end()) {
	                    result += hashMap[num];
	                }
	            }
	        }
	
	        return result;
	    }
	};

#### 383. 赎金信 ####

![](https://s3.uuu.ovh/imgs/2023/08/15/bb5e7d3baf1b3362.png)

	class Solution {
	public:
	    bool canConstruct(string ransomNote, string magazine) {
	        unordered_map<int, int> hashMap;
	        for (int i = 0; i < magazine.size(); i++) {
	            hashMap[magazine[i]]++;
	        }
	
	        for (int i = 0; i < ransomNote.size(); i++) {
	            auto iter = hashMap.find(ransomNote[i]);
	            if (iter == hashMap.end() || iter->second <= 0) {
	                return false;
	            }
	
	            iter->second--;
	        }
	
	        return true;
	    }
	};

#### 15. 三数之和 ####

![](https://s3.uuu.ovh/imgs/2023/08/22/8b19bb45c4418ade.png)

	class Solution {
	public:
	    vector<vector<int>> threeSum(vector<int>& nums) {
	        vector<vector<int>> result;
	        sort(nums.begin(), nums.end());
	        for (int i = 0; i < nums.size(); i++) {
	            if (nums[i] > 0) {
	                return result;
	            }
	
	            if (i > 0 && nums[i] == nums[i - 1]) {
	                continue;
	            }
	
	            int left = i + 1;
	            int right = nums.size() - 1;
	            while (left < right) {
	                if (nums[i] + nums[left] + nums[right] == 0) {
	                    result.emplace_back(vector<int>{nums[i], nums[left], nums[right]});
	                    while (left + 1 < nums.size() && nums[left] == nums[left + 1]) {
	                        left++;
	                    }
	
	                    while (right - 1 >= 0 && nums[right] == nums[right - 1]) {
	                        right--;
	                    }
	
	                    left++;
	                    right--;
	                } else if (nums[i] + nums[left] + nums[right] > 0) {
	                    right--;
	                } else {
	                    left++;
	                }
	            }
	        }
	
	        return result;
	    }
	};

#### 18. 四数之和 ####

![](https://s3.uuu.ovh/imgs/2023/08/23/ab0b0dc1954cb6d2.png)

	class Solution {
	public:
	    vector<vector<int>> fourSum(vector<int>& nums, int target) {
	        vector<vector<int>> result;
	        sort(nums.begin(), nums.end());
	        for (int i = 0; i < nums.size(); i++) {
	            if (i > 0 && nums[i] == nums[i - 1]) {
	                continue;
	            }
	
	            for (int j = i + 1; j < nums.size(); j++) {
	                if (j > i + 1 && nums[j] == nums[j - 1]) {
	                    continue;
	                }
	
	                int left = j + 1;
	                int right = nums.size() - 1;
	                while (left < right) {
	                    if ((long)nums[i] + nums[j] + nums[left] + nums[right] > target) {
	                        right--;
	                    } else if ((long)nums[i] + nums[j] + nums[left] + nums[right] < target) {
	                        left++;
	                    } else {
	                        result.emplace_back(vector<int>{nums[i], nums[j], nums[left], nums[right]});
	                        while (left < right && nums[left] == nums[left + 1]) left++;
	                        while (left < right && nums[right] == nums[right - 1]) right--;
	                        left++;
	                        right--;
	                    }
	                }
	            }
	        }
	
	        return result;
	    }
	};

### <a name="chapter5"></a>第五章 字符串

#### 344. 反转字符串 ####

![](https://s3.uuu.ovh/imgs/2023/08/23/7f4b5cb3d35526e7.png)

	class Solution {
	public:
	    void reverseString(vector<char>& s) {
	        int left = 0;
	        int right = s.size() - 1;
	        while (left < right) {
	            char tmp = s[left];
	            s[left] = s[right];
	            s[right] = tmp;
	            left++;
	            right--;
	        }
	    }
	};

#### 541. 反转字符串 II ####

![](https://s3.uuu.ovh/imgs/2023/08/23/ecfd63eb2a720a70.png)

	class Solution {
	public:
	    string reverseStr(string s, int k) {
	        int pos = 0;
	        for (int i = 2 * k - 1; i < s.size(); i += 2 *k) {
	            reverse(s.begin() + pos, s.begin() + pos + k);
	            pos = i + 1;
	        }
	
	        if (s.size() - pos > k) {
	            reverse(s.begin() + pos, s.begin() + pos + k);
	        } else {
	            reverse(s.begin() + pos, s.end());
	        }
	
	        return s;
	    }
	};

#### 剑指 Offer 05. 替换空格 ####

![](https://s3.uuu.ovh/imgs/2023/08/23/3219b9c29daf3940.png)

	class Solution {
	public:
	    string replaceSpace(string s) {
	        int left = s.size() - 1;
	        int spaceNum = 0;
	        for (int i = 0; i < s.size(); i++) {
	            if (s[i] == ' ') {
	                spaceNum++;
	            }
	        }
	
	        s.resize(left + 1 + 2 * spaceNum);
	        int right = s.size() - 1;
	        while (left >= 0) {
	            if (s[left] != ' ') {
	                s[right--] = s[left--];
	            } else {
	                s[right--] = '0';
	                s[right--] = '2';
	                s[right--] = '%';
	                left--;
	            }
	        }
	
	        return s;
	    }
	};

#### 151. 反转字符串中的单词 ####

![](https://s3.uuu.ovh/imgs/2023/08/25/cc62a0df1541fc5c.png)

	class Solution {
	public:
	    string reverseWords(string s) {
	        int slow = 0; 
	        for (int i = 0; i < s.size(); ++i) {
	            if (s[i] != ' ') {
	                if (slow != 0) s[slow++] = ' ';
	                while (i < s.size() && s[i] != ' ') {
	                    s[slow++] = s[i++];
	                }
	            }
	        }
	        s.resize(slow);
	
	        int pos = 0;
	        int valid = 0;
	        string result = "";
	        for (int i = 0; i < s.size(); i++) {
	            if (s[i] == ' ') {
	                reverse(s.begin() + pos, s.begin() + i);
	                pos = i + 1;
	                valid = 0;
	            }
	        }
	
	        reverse(s.begin() + pos, s.end());
	        reverse(s.begin(), s.end());
	        return s;
	    }
	};

#### 剑指 Offer 58 - II. 左旋转字符串 ####

![](https://s3.uuu.ovh/imgs/2023/08/25/660ad836f3ec9e52.png)

	class Solution {
	public:
	    string reverseLeftWords(string s, int n) {
	        reverse(s.begin(), s.end());
	        reverse(s.begin(), s.begin() + s.size() - n);
	        reverse(s.begin() + s.size() -n, s.end());
	        return s;
	    }
	};

#### 28. 找出字符串中第一个匹配项的下标 ####

![](https://s3.uuu.ovh/imgs/2023/08/26/6e09fbeb4ff08672.png)

	class Solution {
	public:
	    int strStr(string haystack, string needle) {
	        if (needle.size() > haystack.size()) {
	            return -1;
	        }
	
	        int j = 0;
	        for (int i = 0; i < haystack.size() - needle.size() + 1; i++) {
	            int index = i;
	            for (j = 0; j < needle.size(); j++) {
	                if (haystack[index] == needle[j]) {
	                    index++;
	                    continue;
	                }
	
	                break;
	            }
	
	            if (j == needle.size()) {
	                return i;
	            }
	        }
	
	        return -1;
	    }
	};

#### 459. 重复的子字符串 ####

![](https://s3.uuu.ovh/imgs/2023/08/26/ebde6fadec0ab458.png)

	class Solution {
	public:
	    bool repeatedSubstringPattern(string s) {
	        for (int i = 1; i <= s.size() / 2; i++) {
	            if (s.size() % i != 0) {
	                continue;
	            }
	
	            string tmp = s.substr(0, i);
	            int j = i;
	            for (j = i; j < s.size(); j += i) {
	                if (s.substr(j, i) == tmp) {
	                    continue;
	                } else {
	                    break;
	                }
	            }
	
	            if (j == s.size()) {
	                return true;
	            }
	        }
	
	        return false;
	    }
	};

### <a name="chapter6"></a>第六章 双指针法

#### 27. 移除元素 ####

![](https://s3.uuu.ovh/imgs/2023/08/26/d0bf64ca8a6c0130.png)

	class Solution {
	public:
	    int removeElement(vector<int>& nums, int val) {
	        for (int i = 0; i < nums.size(); i++) {
	            if (nums[i] == val) {
	                nums.erase(nums.begin() + i);
	                i--;
	            }
	        }
	
	        return nums.size();
	    }
	};

### <a name="chapter7"></a>第气章 栈与队列

#### 232. 用栈实现队列 ####

![](https://s3.uuu.ovh/imgs/2023/08/26/e91faad59166f8d5.png)

	class MyQueue {
	public:
	    stack<int> stack1;
	    stack<int> stack2;
	
	    MyQueue() {
	
	    }
	    
	    void push(int x) {
	        if (stack1.empty() && stack2.empty()) {
	            stack1.push(x);
	        } else if (stack1.empty()) {
	            while (!stack2.empty()) {
	                int val = stack2.top();
	                stack2.pop();
	                stack1.push(val);
	            }
	
	            stack1.push(x);
	        } else {
	            stack1.push(x);
	        }
	    }
	    
	    int pop() {
	        if (!stack1.empty()) {
	            int val;
	            while (!stack1.empty()) {
	                val = stack1.top();
	                stack1.pop();
	                stack2.push(val);
	            }
	
	            stack2.pop();
	            return val;
	        } else {
	            int val = stack2.top();
	            stack2.pop();
	            return val;
	        }
	    }
	    
	    int peek() {
	        if (!stack1.empty()) {
	            while (!stack1.empty()) {
	                int val = stack1.top();
	                stack1.pop();
	                stack2.push(val);
	            }
	
	            return stack2.top();
	        } else {
	            int val = stack2.top();
	            return val;
	        }
	    }
	    
	    bool empty() {
	        if (stack1.empty() && stack2.empty()) {
	            return true;
	        }
	
	        return false;
	    }
	};
	
	/**
	 * Your MyQueue object will be instantiated and called as such:
	 * MyQueue* obj = new MyQueue();
	 * obj->push(x);
	 * int param_2 = obj->pop();
	 * int param_3 = obj->peek();
	 * bool param_4 = obj->empty();
	 */

#### 232. 用栈实现队列 ####

![](https://s3.bmp.ovh/imgs/2023/08/27/a7b59d77bdf92609.png)

	class MyStack {
	public:
	    queue<int> q1;
	    queue<int> q2;
	    MyStack() {
	
	    }
	    
	    void push(int x) {
	        if (q2.empty()) {
	            q1.push(x);
	        } else {
	            q2.push(x);
	        }
	    }
	    
	    int pop() {
	        if (q1.empty()) {
	            int val;
	            while (q2.size() > 1) {
	                val = q2.front();
	                q2.pop();
	                q1.push(val);
	            }
	
	            val = q2.front();
	            q2.pop();
	            return val;
	        } else {
	            int val;
	            while (q1.size() > 1) {
	                val = q1.front();
	                q1.pop();
	                q2.push(val);
	            }
	
	            val = q1.front();
	            q1.pop();
	            return val;
	        }
	    }
	    
	    int top() {
	        if (q1.empty()) {
	            int val;
	            while (q2.size() > 0) {
	                val = q2.front();
	                q2.pop();
	                q1.push(val);
	            }
	
	            return val;
	        } else {
	            int val;
	            while (q1.size() > 0) {
	                val = q1.front();
	                q1.pop();
	                q2.push(val);
	            }
	
	            return val;
	        }
	    }
	    
	    bool empty() {
	        if (q1.empty() && q2.empty()) {
	            return true;
	        }
	
	        return false;
	    }
	};
	
	/**
	 * Your MyStack object will be instantiated and called as such:
	 * MyStack* obj = new MyStack();
	 * obj->push(x);
	 * int param_2 = obj->pop();
	 * int param_3 = obj->top();
	 * bool param_4 = obj->empty();
	 */

#### 20. 有效的括号 ####

![](https://s3.uuu.ovh/imgs/2023/08/27/c56a0f7a396c0013.png)

	class Solution {
	public:
	    bool isValid(string s) {
	        stack<char> stk;
	        for (int i = 0; i < s.size(); i++) {
	            if (s[i] == '(' || s[i] == '[' || s[i] == '{') {
	                stk.push(s[i]);
	            } else if (!stk.empty()) {
	                char tmp = stk.top();
	                if (s[i] == ')') {
	                    if (tmp != '(') {
	                        return false;
	                    } else {
	                        stk.pop();
	                    }
	                } else if (s[i] == ']') {
	                    if (tmp != '[') {
	                        return false;
	                    } else {
	                        stk.pop();
	                    }
	                } else if (s[i] == '}') {
	                    if (tmp != '{') {
	                        return false;
	                    } else {
	                        stk.pop();
	                    }
	                }
	            } else {
	                return false;
	            }
	        }
	
	        if (stk.empty()) {
	            return true;
	        }
	
	        return false;
	    }
	};

#### 1047. 删除字符串中的所有相邻重复项 ####

![](https://s3.uuu.ovh/imgs/2023/09/03/b9858c1f782a9b8a.png)

	class Solution {
	public:
	    string removeDuplicates(string s) {
	        string result;
	        stack<char> stk;
	        for (int i = 0; i < s.size(); i++) {
	            if (stk.empty()) {
	                stk.push(s[i]);
	                continue;
	            }
	
	            char tmp = stk.top();
	            if (s[i] == tmp) {
	                stk.pop();
	            } else {
	                stk.push(s[i]);
	            }
	        }
	
	        while (!stk.empty()) {
	            result += stk.top();
	            stk.pop();
	        }
	
	        reverse(result.begin(), result.end());
	        return result;
	    }
	};

#### 150. 逆波兰表达式求值 ####

![](https://s3.uuu.ovh/imgs/2023/09/03/cc4d230bb85b448f.png)

	class Solution {
	public:
	    int evalRPN(vector<string>& tokens) {
	        stack<string> stk;
	        for (int i = 0; i < tokens.size(); i++) {
	            if (stk.empty() || (tokens[i] != "+" && tokens[i] != "-" && tokens[i] != "*" && tokens[i] != "/")) {
	                stk.push(tokens[i]);
	            } else {
	                int num;
	                int n2 = stoi(stk.top());
	                stk.pop();
	                int n1 = stoi(stk.top());
	                stk.pop();
	                if (tokens[i] == "+") {
	                    num = n1 + n2;
	                } else if (tokens[i] == "-") {
	                    num = n1 - n2;
	                } else if (tokens[i] == "*") {
	                    num = n1 * n2;
	                } else if (tokens[i] == "/") {
	                    num = n1 / n2;
	                }
	
	                stk.push(to_string(num));
	            }
	        }
	
	        return stoi(stk.top());
	    }
	};

#### 239. 滑动窗口最大值 ####

![](https://s3.uuu.ovh/imgs/2023/09/03/d17ae89cfd8c4959.png)

	class Solution {
	public:
	    class MyQueue {
	        public:
	        deque<int> dq;
	        void pop(int value) {
	            if (!dq.empty() && dq.front() == value) {
	                dq.pop_front();
	            }
	        }
	
	        void push_back(int value) {
	            if (dq.empty() || value <= dq.back()) {
	                dq.push_back(value);
	            } else {
	                while (!dq.empty() && value > dq.back()) {
	                    dq.pop_back();
	                }
	
	                dq.push_back(value);
	            }
	        }
	
	        int front() {
	            return dq.front();
	        }
	    };
	
	    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
	        vector<int> result;
	        MyQueue mq;
	        for (int i = 0; i < k; i++) {
	            mq.push_back(nums[i]);
	        }
	
	        result.push_back(mq.front());
	        for (int i = k; i < nums.size(); i++) {
	            mq.pop(nums[i - k]);
	            mq.push_back(nums[i]);
	            result.push_back(mq.front());
	        }
	
	        return result;
	    }
	};

#### <font color="#0000dd">347. 前 K 个高频元素</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/09/06/a2fd61168cd82859.png)

	class Solution {
	public:
	    class compare {
	    public:
	        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
	            return lhs.second > rhs.second;
	        }
	    };
	
	    vector<int> topKFrequent(vector<int>& nums, int k) {
	        vector<int> result;
	        unordered_map<int, int> hashMap;
	        for (int i = 0; i < nums.size(); i++) {
	            hashMap[nums[i]]++;
	        }
	
	        priority_queue<pair<int, int>, vector<pair<int, int>>, compare> priQue;
	        for (auto iter : hashMap) {
	            priQue.push(iter);
	            if (priQue.size() > k) {
	                priQue.pop();
	            }
	        }
	
	        for (int i = k - 1; i >= 0; i--) {
	            int tmpNum = priQue.top().first;
	            priQue.pop();
	            result.emplace_back(tmpNum);
	        }
	
	        return result;
	    }
	};

### <a name="chapter7"></a>第七章 二叉树

#### 144. 二叉树的前序遍历 ####

![](https://s3.uuu.ovh/imgs/2023/09/04/21f9fc2d3569c0ae.png)

	class Solution {
	public:
	    vector<int> result;
	    void preOrder(TreeNode *node) {
	        if (node == nullptr) {
	            return;
	        }
	
	        result.emplace_back(node->val);
	        preOrder(node->left);
	        preOrder(node->right);
	    }
	
	    vector<int> preorderTraversal(TreeNode* root) {
	        preOrder(root);
	        return result;
	    }
	};

#### 145. 二叉树的后序遍历 ####

![](https://s3.uuu.ovh/imgs/2023/09/04/fa859d5769fb6829.png)

	class Solution {
	public:
	    vector<int> result;
	    void postOrder(TreeNode *node) {
	        if (node == nullptr) {
	            return;
	        }
	
	        postOrder(node->left);
	        postOrder(node->right);
	        result.emplace_back(node->val);
	    }
	
	    vector<int> postorderTraversal(TreeNode* root) {
	        postOrder(root);
	        return result;
	    }
	};

#### 94. 二叉树的中序遍历 ####

![](https://s3.uuu.ovh/imgs/2023/09/04/ee453ad4814be538.png)

	class Solution {
	public:
	    vector<int> result;
	    void inOrder(TreeNode *node) {
	        if (node == nullptr) {
	            return;
	        }
	
	        inOrder(node->left);
	        result.emplace_back(node->val);
	        inOrder(node->right);
	    }
	
	    vector<int> inorderTraversal(TreeNode* root) {
	        inOrder(root);
	        return result;
	    }
	};

#### 102. 二叉树的层序遍历 ####

![](https://s3.uuu.ovh/imgs/2023/09/05/0fa71de2ee0dd319.png)

	class Solution {
	public:
	    vector<vector<int>> levelOrder(TreeNode* root) {
	        vector<vector<int>> result;
	        if (root == nullptr) {
	            return result;
	        }
	
	        queue<TreeNode*> treeQue;
	        treeQue.push(root);
	        while (!treeQue.empty()) {
	            int size = treeQue.size();
	            vector<int> path;
	            for (int i = 0; i < size; i++) {
	                TreeNode *node = treeQue.front();
	                treeQue.pop();
	                path.emplace_back(node->val);
	                if (node->left) {
	                    treeQue.push(node->left);
	                }
	
	                if (node->right) {
	                    treeQue.push(node->right);
	                }
	            }
	
	            result.emplace_back(path);
	        }
	
	        return result;
	    }
	};

### 参考资源

* [Leetcode](https://leetcode.cn/problemset/all/)
* [代码随想录](https://www.programmercarl.com/)

转载请注明：[sizheluo的博客](https://sizheluo.github.io) » [JZ_Note](https://sizheluo.github.io/2023/07/代码随想录/)