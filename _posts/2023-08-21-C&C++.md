---
layout: post
title: "C&C++"
date: 2023-08-21
description: "C/C++学习"
tag: C/C++
---

### 前言

　　`前言`内容。

### 目录

* [第一章](#chapter1)
* [第二章](#chapter2)
* [第三章](#chapter3)
* [第四章](#chapter4)
* [第五章](#chapter5)
* [第六章](#chapter6)
* [第七章](#chapter7)
* [第八章](#chapter8)

### <a name="chapter1"></a>C++编译过程

![](https://s3.uuu.ovh/imgs/2023/09/17/54952f0c42d6e8d4.png)

> 编译过程分为四个过程：预编译、编译、汇编，链接。

（1）预处理阶段：gcc -E hello.c -o hello.i
对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。

（2）编译阶段：gcc –S hello.i –o hello.s
将经过预处理后的预编译文件转换成特定汇编代码（编译原理相关，词法分析、语法分析、语义分析等），生成汇编文件

（3）汇编阶段：gcc –c hello.s –o hello.o
将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件

（4）链接阶段：gcc hello.o –o hello
将多个目标文件及所需要的库打包连接成最终的可执行目标文件（或库文件以供其他程序使用）

> 链接分为两种：

> 静态链接：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。

> 动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。
二者的优缺点：

    静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。
    动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。

### <a name="chapter2"></a>第二章 从C到C++

> 面向对象程序设计：封装、继承和多态

1. const

1.1 C++中的const更像编译阶段的#define

> C语言对 const 的处理和普通变量一样，会到内存中读取数据；C++ 对 const 的处理更像是编译时期的#define，是一个值替换的过程。

1.2 C++中全局const变量的可见范围是当前文件

> C和C++中全局 const 变量的作用域相同，都是当前文件，不同的是它们的可见范围：C语言中 const 全局变量的可见范围是整个程序，在其他文件中使用 extern 声明后就可以使用；而C++中 const 全局变量的可见范围仅限于当前文件，在其他文件中不可见，所以它可以定义在头文件中，多次引入后也不会出错。

2. 函数重载

 - 函数名称必须相同。
 - 参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）。
 - 函数的返回类型可以相同也可以不相同。
 - 仅仅返回类型不同不足以成为函数的重载
 - C++函数重载过程中的二义性（类型提升）和类型转换

3. C++和C的混合编程

 - extern "C"，例如在头文件中修饰某一个函数或者{}

### <a name="chapter3"></a>第三章 类和对象

1. 在类体中和类体外定义成员函数的区别

> 在类体中定义的成员函数会自动成为`内联函数`，在类体外定义的不会

2. 构造函数

> 构造函数的调用是`强制性`的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的，未定义的话编译器会自动生成`默认构造函数`。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配。

> 成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在`类中声明的顺序`有关。

> 初始化const成员变量的`唯一方法`就是使用初始化列表。

- class和struct到底有什么区别

> 使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的

> class 继承默认是 private 继承，而 struct 继承默认是 public 继承

> class 可以使用模板，而 struct 不能

### <a name="chapter4"></a>第四章 C++引用

1. 引用必须在定义的同时初始化，并且以后也要从一而终，不能再引用其它数据，这有点类似于常量（const 变量）。

2. 引用在定义时需要添加&，在使用时不能添加&，使用时添加&表示取地址。

3. 与指针的区别：

> (1) 引用只是对指针进行了简单的封装，它的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样，在 32 位环境下是 4 个字节，在 64 位环境下是 8 个字节，之所以不能获取引用的地址，是因为编译器进行了内部转换。

> (2) 引用必须在定义时初始化

> (3) 指针可以有多级，但是引用只能有一级，例如，int **p是合法的，而int &&r是不合法的

> (4) 指针和引用的自增（++）自减（--）运算意义不一样。对指针使用 ++ 表示指向下一份数据，对引用使用 ++ 表示它所指代的数据本身加 1

4.引用不能绑定到临时数据

> 编译器会为const引用创建临时变量，编译器为常引用创建临时变量是合理的

### <a name="chapter5"></a>第五章 继承与派生

1.protected 成员和 private 成员类似，也不能通过对象访问。但是当存在继承关系时，protected 和 private 就不一样了：基类中的 protected 成员可以在派生类中使用，而基类中的 private 成员不能在派生类中使用

2.public、protected、private 指定继承方式：

> 1) public继承方式  
基类中所有 public 成员在派生类中为 public 属性；  
基类中所有 protected 成员在派生类中为 protected 属性；  
基类中所有 private 成员在派生类中不能使用。  

> 2) protected继承方式  
基类中的所有 public 成员在派生类中为 protected 属性；  
基类中的所有 protected 成员在派生类中为 protected 属性；  
基类中的所有 private 成员在派生类中不能使用。  

> 3) private继承方式  
基类中的所有 public 成员在派生类中均为 private 属性；  
基类中的所有 protected 成员在派生类中均为 private 属性；  
基类中的所有 private 成员在派生类中不能使用。

> 在派生类中访问基类 private 成员的唯一方法就是借助基类的非 private 成员函数，如果基类没有非 private 成员函数，那么该成员在派生类中将无法访问。

> 使用 using 关键字可以改变基类成员在派生类中的访问权限，例如将 public 改为 private、将 protected 改为 public。

3.C++继承时的名字遮蔽问题，要加上类名和域解析符访问

> C++类继承时的作用域嵌套，派生类的作用域位于基类作用域之内

4.继承时的对象内存模型

> 派生类的内存模型可以看成是基类成员变量和新增成员变量的总和，而所有成员函数仍然存储在另外一个区域——代码区，由所有对象共享

> 内存分布中，基类的成员变量排在前面，派生类的排在后面

5.基类和派生类的构造函数

> 不同于普通的成员函数，类的构造函数不能被继承  
解决派生类构造函数的一般做法是在派生类的构造函数中调用基类的构造函数  
构造函数的调用顺序：基类构造函数总是被优先调用

6.基类和派生类的析构函数

> 析构函数的执行顺序和继承顺序相反，即先执行派生类析构函数，再执行基类析构函数。

7.多继承（多重继承）

		class D: public A, private B, protected C{
		    //类D新增加的成员
		}

> 多继承形式下的构造函数和单继承形式基本相同，只是要在派生类的构造函数中调用多个基类的构造函数。

> 多继承时的对象内存模型：在内存中基类对象的排列顺序和继承时声明的顺序相同。

> 菱形继承： 类 A 派生出类 B 和类 C，类 D 继承自类 B 和类 C

8.虚继承：为了解决多继承（e.g. 菱形继承）出现的命名冲突和冗余数据的问题

![](https://s3.uuu.ovh/imgs/2023/10/22/a94da47a950d1f0c.png)

> ##### 被共享的基类A就称为虚基类（Virtual Base Class）

> 以图中的菱形继承为例，假设 A 定义了一个名为 x 的成员变量，当我们在 D 中直接访问 x 时，会有三种可能性：  
如果 B 和 C 中都没有 x 的定义，那么 x 将被解析为 A 的成员，此时不存在二义性。  
如果 B 或 C 其中的一个类定义了 x，也不会有二义性，派生类的 x 比虚基类的 x 优先级更高。  
如果 B 和 C 中都定义了 x，那么直接访问 x 将产生二义性问题。

> ##### 虚继承时的构造函数：
（1）虚基类是由最终的派生类初始化的（在普通继承中，派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的）  
（2）虚继承时构造函数的执行顺序与普通继承时不同：在最终派生类的构造函数调用列表中，不管各个构造函数出现的顺序如何，编译器总是先调用虚基类的构造函数，再按照出现的顺序调用其他的构造函数（普通继承就是按照构造函数出现的顺序依次调用的）

> 虚继承下的内存模型：  
例：class A / class B: public A / class C: public B / class D: public C  
1）普通继承：  
![](https://s3.uuu.ovh/imgs/2023/10/22/6914f81bcabfca2f.png)  
2）A 是 B 的虚基类： class B: virtual public A  
![](https://s3.uuu.ovh/imgs/2023/10/22/1c740347f8b15649.png)  
3）A 是 B 的虚基类，B 又是 C 的虚基类  
![](https://s3.uuu.ovh/imgs/2023/10/22/39f4e1b1bbd90f42.png)  
对于虚继承，将派生类分为固定部分和共享部分，并把共享部分放在最后

9.将派生类赋值给基类（向上转型）
> (1)将派生类对象赋值给基类对象、将派生类指针赋值给基类指针、将派生类引用赋值给基类引用，这在 C++ 中称为向上转型（Upcasting）。相应地，将基类赋值给派生类称为向下转型（Downcasting）。  
(2)赋值的本质是将现有的数据写入已分配好的内存中，对象的内存只包含了成员变量，所以对象之间的赋值是成员变量的赋值，成员函数不存在赋值问题。

![](https://s3.uuu.ovh/imgs/2023/10/22/ac641c108e4c19b1.png)

### <a name="chapter6"></a>第六章 C++多态与虚函数

1.多态：

> 编译时多态：函数重载（包括运算符重载）  
运行时多态：继承、虚函数

> - 问题：当基类指针 p 指向派生类 Teacher 的对象时，虽然使用了 Teacher 的成员变量，但是却没有使用它的成员函数，导致输出结果不伦不类
> - 措施：基类使用虚函数（Virtual Function）。有了虚函数，基类指针（引用）指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。
> - 注意：派生类构造/析构函数始终会调用基类的构造/析构函数，并且这个过程是隐式的

2.构成多态的条件：

>- 必须存在继承关键
- 继承关系中必须有同名的虚函数，并且它们是覆盖关系（函数原型相同）
- 存在基类的指针，通过该指针调用虚函数虚函数

3.虚析构函数的必要性 [详情](https://c.biancheng.net/view/vip_2297.html)

>为什么没有虚构造函数：

>- 派生类不能继承基类的构造函数，将构造函数声明为虚函数没有意义
>- C++ 中的构造函数用于在创建对象时进行初始化工作，在执行构造函数之前对象尚未创建完成，虚函数表尚不存在，也没有指向虚函数表的指针

4.纯虚函数和抽象类

	virtual 返回值类型 函数名 (函数参数) = 0;
> 纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上=0，表明此函数为纯虚函数，普通成员函数不能声明为纯虚函数（void function = 0 // complie error）

> 包含纯虚函数的类称为抽象类（Abstract Class），抽象类无法实例化

> 抽象类用法：作为基类，让派生类去实现纯虚函数才能被实例化

5.虚函数表（Virtual function table） [详情](https://c.biancheng.net/view/vip_2300.html)

> 一个类包含了虚函数，在创建该类的对象时就会额外地增加一个虚函数表（数组），数组中的每一个元素都是虚函数的入口地址   
> 数组和对象是分开存储的，因此编译器需要在对象中（开头位置）安插一个指针指向数组的位置

5.RTTI机制（Run-Time Type Identification，运行时类型识别机制） [详情]（https://c.biancheng.net/view/vip_2302.html）

> 根据前面讲过的知识，C++ 的对象内存模型主要包含了以下几个方面的内容：

>- 如果没有虚函数也没有虚继承，那么对象内存模型中只有成员变量
- 如果类包含了虚函数，那么会额外添加一个虚函数表，并在对象内存中插入一个指针，指向这个虚函数表
- 如果类包含了虚继承，那么会额外添加一个虚基类表，并在对象内存中插入一个指针，指向这个虚基类表
- 如果类包含了虚函数，那么该类的对象内存中还会额外增加类型信息，也即 type_info 对象

![](https://s3.uuu.ovh/imgs/2023/10/22/97fc2d0bd53ac539.jpg)

### <a name="chapter7"></a>第七章

    第七章内容

### <a name="chapter8"></a>第八章 C++ 11

**1. auto类型推导**

**2. decltype类型推导**

 > auto和decltype的区别:   
 > （1）语法：auto 根据=右边的初始值 value 推导出变量的类型，且必须初始化。decltype 根据 exp 表达式推导出变量的类型，跟=右边的 value 没有关系   
 > （2）对cv的处理：如果表达式的类型不是指针或者引用，auto 会把 cv 限定符直接抛弃，推导成 non-const 或者 non-volatile 类型。如果表达式的类型是指针或者引用，auto 将保留 cv 限定符  
 > （3）对引用的处理：decltype 会保留引用类型，而 auto 会抛弃引用类型
### 参考资源

    参考资源

转载请注明：[sizheluo的博客](https://sizheluo.github.io) » [文章标题](文章链接)