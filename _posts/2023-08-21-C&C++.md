---
layout: post
title: "C&C++"
date: 2023-08-21
description: "C/C++学习"
tag: C/C++
---

### 前言

　　`前言`内容。

### 目录

* [第一章](#chapter1)
* [第二章](#chapter2)
* [第三章](#chapter3)
* [第四章](#chapter4)
* [第五章](#chapter5)
* [第六章](#chapter6)
* [第七章](#chapter7)
* [第八章](#chapter8)

### <a name="chapter1"></a>C++编译过程

![](https://s3.uuu.ovh/imgs/2023/09/17/54952f0c42d6e8d4.png)

> 编译过程分为四个过程：预编译、编译、汇编，链接。

（1）预处理阶段：gcc -E hello.c -o hello.i
对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。

（2）编译阶段：gcc –S hello.i –o hello.s
将经过预处理后的预编译文件转换成特定汇编代码（编译原理相关，词法分析、语法分析、语义分析等），生成汇编文件

（3）汇编阶段：gcc –c hello.s –o hello.o
将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件

（4）链接阶段：gcc hello.o –o hello
将多个目标文件及所需要的库打包连接成最终的可执行目标文件（或库文件以供其他程序使用）

> 链接分为两种：

> 静态链接：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。

> 动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。
二者的优缺点：

    静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。
    动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。

### <a name="chapter2"></a>第二章 从C到C++

1. const

1.1 C++中的const更像编译阶段的#define

> C语言对 const 的处理和普通变量一样，会到内存中读取数据；C++ 对 const 的处理更像是编译时期的#define，是一个值替换的过程。

1.2 C++中全局const变量的可见范围是当前文件

> C和C++中全局 const 变量的作用域相同，都是当前文件，不同的是它们的可见范围：C语言中 const 全局变量的可见范围是整个程序，在其他文件中使用 extern 声明后就可以使用；而C++中 const 全局变量的可见范围仅限于当前文件，在其他文件中不可见，所以它可以定义在头文件中，多次引入后也不会出错。

2. 函数重载

 - 函数名称必须相同。
 - 参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）。
 - 函数的返回类型可以相同也可以不相同。
 - 仅仅返回类型不同不足以成为函数的重载
 - C++函数重载过程中的二义性（类型提升）和类型转换

3. C++和C的混合编程

 - extern "C"，例如在头文件中修饰某一个函数或者{}

### <a name="chapter3"></a>第三章 类和对象

1. 在类体中和类体外定义成员函数的区别

> 在类体中定义的成员函数会自动成为`内联函数`，在类体外定义的不会

2. 构造函数

> 构造函数的调用是`强制性`的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的，未定义的话编译器会自动生成`默认构造函数`。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配。

> 成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在`类中声明的顺序`有关。

> 初始化const成员变量的`唯一方法`就是使用初始化列表。

### <a name="chapter4"></a>第四章

    第四章内容

### <a name="chapter5"></a>第五章

    第五章内容

### <a name="chapter6"></a>第六章

    第六章内容

### <a name="chapter7"></a>第七章

    第七章内容

### <a name="chapter8"></a>第八章 C++ 11

**1. auto类型推导**

**2. decltype类型推导**

 > auto和decltype的区别:   
 > （1）语法：auto 根据=右边的初始值 value 推导出变量的类型，且必须初始化。decltype 根据 exp 表达式推导出变量的类型，跟=右边的 value 没有关系   
 > （2）对cv的处理：如果表达式的类型不是指针或者引用，auto 会把 cv 限定符直接抛弃，推导成 non-const 或者 non-volatile 类型。如果表达式的类型是指针或者引用，auto 将保留 cv 限定符  
 > （3）对引用的处理：decltype 会保留引用类型，而 auto 会抛弃引用类型
### 参考资源

    参考资源

转载请注明：[sizheluo的博客](https://sizheluo.github.io) » [文章标题](文章链接)