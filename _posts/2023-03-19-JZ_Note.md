---
layout: post
title: "2023-03-19-JZ_Note"
date: 2023-03-19
description: "JZ算法题"
tag: 算法
---

### 前言

	`JZ算法题记录。`

### 目录

* [第一章](#chapter1)
* [第二章](#chapter2)
* [第三章](#chapter3)
* [第四章](#chapter4)
* [第五章](#chapter5)
* [第六章](#chapter6)
* [第七章](#chapter7)
* [第八章](#chapter8)

### <a name="chapter1"></a>第一章

    第一章内容

### <a name="chapter2"></a>第二章 面试需要的基础知识

#### 前置知识 ####

一、关于sizeof
定义一个空类型，求sizeof得到的结果是1。空实例不包含任何信息 ，但必须在内存中占有一定的空间，否则无法使用这些实例。
再添加一个构造函数和析构函数，sizeof的结果还是1。调用构造函数只需要知道函数的地址即可，而这些函数的地址只与类型相关，而与类型的实例无关。
把析构函数标记为虚函数，sizeof的值为4或者8，为指针占用空间，会生成虚函数表，并在类的每一个实例中添加一个指向虚函数的指针。

#### 面试题1：赋值运算符函数 ####

#### 面试题2：实现Singleton模式，设计一个类，我们只能生成该类的一个实例 ####

#### 面试题3：数组中重复的数字 ####

在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。
也不知道每个数字重复几次。请找出数组中第一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，
那么对应的输出是第一个重复的数字2。
返回描述：
如果数组中有重复的数字，函数返回true，否则返回false。
如果数组中有重复的数字，把重复的数字放到参数duplication[0]中。（ps:duplication已经初始化，可以直接赋值使用。）

    class Solution {
    public:
	    bool duplicate(int numbers[], int length, int* duplication) {
	    	bool haveDuplication;
	    	int index = 0;
	    	vector<int> hashTable(length, -1);
	    	for (int i = 0; i < length; i++) {
		    	if (hashTable[numbers[i]] == -1) {
		    		hashTable[numbers[i]] = numbers[i];
		    	} else if (hashTable[numbers[i]] == numbers[i]) {
		    		duplication[index] = numbers[i];
				    index++;
				    break;
		    	}
	    	}
	    
		    if (index == 0) {
		    	haveDuplication = false;
		    } else {
		    	haveDuplication = true;
		    }
	    
	    	return haveDuplication;
	    }
    };

#### 面试题4： 二维数组中的查找 ####

在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
[
[1,2,8,9],
[2,4,9,12],
[4,7,10,13],
[6,8,11,15]
]
给定 target = 7，返回 true。
给定 target = 3，返回 false。

	class Solution {
	public:
	    int rightAndUp(int row, int column, vector<vector<int>> array)
	    {
	        return array[row][column];
	    }
	
	    bool Find(int target, vector<vector<int> > array) {
	        if (array.size() == 0 || array[0].size() == 0) {
	            return false;
	        }
	
	        int row = 0;
	        int column = array[0].size() - 1;
	        int value = array[row][column];
	        bool isFind = false;
	        while (true) {
	            cout << value << endl;
	            if (value > target) {
	                column--;
	            } else if (value < target) {
	                row++;
	            } else {
	                isFind = true;
	                break;
	            }
	
	            if (row == array.size() || column < 0) {
	                break;
	            } else {
	                value = rightAndUp(row, column, array);
	            }
	        }
	       
	        return isFind;
	    }
	};

#### 面试题5：替换空格 ####

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

	class Solution {
	public:
	    void replaceSpace(char *str,int length) {
	        int spaceNum = 0;
	        for (int i = 0; i < length; i++) {
	            if (str[i] == ' ') {
	                spaceNum++;
	            }
	        }
	
	        int paddingLen = 2 * spaceNum;
	        for (int i = (length + paddingLen), j = length; i >= 0 && j >= 0;) {
	            if (str[j] == ' ') {
	                str[i] = '0';
	                i--;
	                str[i] = '2';
	                i--;
	                str[i] = '%';
	                i--;
	                j--;
	            } else {
	                str[i] = str[j];
	                i--;
	                j--;
	            }
	        }
	
	        return;
	    }
	};

#### 面试题6：从尾到头打印链表 ####

输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。
如输入{1,2,3}的链表如下图:

![](https://s3.uuu.ovh/imgs/2023/03/20/17883538d3b8dd23.png#pic_left)

返回一个数组为[3,2,1]
0 <= 链表长度 <= 10000

	/**
	*  struct ListNode {
	*      int val;
	*      struct ListNode *next;
	*       ListNode(int x) :
	*           val(x), next(NULL) {
	*       }
	*  };
	*/

	class Solution {
	public:
	vector<int> result;
	void printListReverse(ListNode *node) {
	if (node != nullptr) {
	printListReverse(node->next);
	result.emplace_back(node->val);
	}
	
	return;
	}
	
	vector<int> printListFromTailToHead(ListNode* head) {
	printListReverse(head);
	return result;
	}
	};

#### 面试题7：重建二叉树 ####

![](https://s3.uuu.ovh/imgs/2023/03/22/698ec397835ee4d4.png)

	/**
	 * Definition for binary tree
	 * struct TreeNode {
	 *     int val;
	 *     TreeNode *left;
	 *     TreeNode *right;
	 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
	 * };
	 */
	class Solution {
	public:
	    TreeNode* reConstructInternal(vector<int> pre, vector<int> vin)
	    {
	        if (pre.size() == 0 || vin.size() == 0) {
	            return nullptr;
	        }
	
	        TreeNode *node = new TreeNode(pre[0]);
	        int indexInVin = 0;
	        for (int i = 0; i < vin.size(); i++) {
	            if (pre[0] == vin[i]) {
	                indexInVin = i;
	                break;
	            }
	        }
	
	        vector<int> leftPre(pre.begin() + 1, pre.begin() + 1 + indexInVin);
	        vector<int> rightPre(pre.begin() + 1 + indexInVin, pre.end());
	
	        vector<int> leftVin(vin.begin(), vin.begin() + indexInVin);
	        vector<int> rightVin(vin.begin() + indexInVin + 1, vin.end());
	
	        node->left = reConstructInternal(leftPre, leftVin);
	        node->right = reConstructInternal(rightPre, rightVin);
	
	        return node;
	    }
	
	    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
	        TreeNode *root = reConstructInternal(pre, vin);
	        return root;
	    }
	};

#### <font color="#0000dd">面试题8：重建二叉树描述</font><br /> ####

给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。下图为一棵有9个节点的二叉树。树中从父节点指向子节点的指针用实线表示，从子节点指向父节点的用虚线表示

![](https://s3.uuu.ovh/imgs/2023/03/20/6edf66e09fa2f118.png#pic_left)

	/*
	struct TreeLinkNode {
	    int val;
	    struct TreeLinkNode *left;
	    struct TreeLinkNode *right;
	    struct TreeLinkNode *next;
	    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) {
	       
	    }
	};
	*/
	class Solution {
	public:
	    TreeLinkNode* GetNext(TreeLinkNode* pNode) {
	        if (pNode == nullptr) {
	            return nullptr;
	        }
	
	        if (pNode->right != nullptr) { // 第一种情况，存在右子树
	            if (pNode->right->left == nullptr) {
	                return pNode->right;
	            } else {
	                TreeLinkNode *node = pNode->right;
	                while (node->left) {
	                    node = node->left;
	                }
	
	                return node;
	            }
	        } else {
	            if (pNode->next == nullptr) {
	                return nullptr;
	            } else if (pNode->next->left == pNode) {  // 第二种情况，不存在右子树且为父节点左子书
	                return pNode->next;
	            } else { // 第三种情况，不存在左子树且为父节点的右子树
	                TreeLinkNode *node = pNode->next;
	                TreeLinkNode *result = nullptr;
	                while (node->next) {
	                    if (node == node->next->left) {
	                        result = node->next;
	                        break;
	                    }
	
	                    node = node->next;
	                }
	
	                return result;
	            }
	        }
	    }
	};

#### 面试题9：用两个栈实现队列 ####

用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。

数据范围： n≤1000
要求：存储n个元素的空间复杂度为 O(n) ，插入与删除的时间复杂度都是 O(1)

	class Solution
	{
	public:
	    void push(int node) {
	        if (stack1.empty() && stack2.empty()) {
	            stack1.push(node);
	        } else if (!stack1.empty()) {
	            stack1.push(node);
	        } else {
	            stack1.push(node);
	        }
	    }
	
	    int pop() {
	        if (stack2.empty() && !stack1.empty()) {
	            int val;
	            while (!stack1.empty()) {
	                val = stack1.top();
	                stack1.pop();
	                stack2.push(val);
	            }
	
	            val = stack2.top();
	            stack2.pop();
	            return val;
	        } else {
	            int val = stack2.top();
	            stack2.pop();
	            return val;
	        }
	    }
	
	private:
	    stack<int> stack1;
	    stack<int> stack2;
	};

#### 面试题10：斐波那契数列 ####

	class Solution {
	public:
	    int Fibonacci(int n) {
	        if (n == 1 || n == 2) {
	            return 1;
	        } else {
	            return Fibonacci(n - 1) + Fibonacci(n - 2);
	        }
	    }
	};


#### <font color="#0000dd">面试题11：旋转数组的最小数字</font><br /> ####

有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。
数据范围：1≤n≤10000，数组中任意元素的值: 0≤val≤10000
要求：空间复杂度：O(1) ，时间复杂度：O(logn)

	class Solution {
	public:
	    int minNumberInRotateArray(vector<int> rotateArray) {
	        int left = 0;
	        int right = rotateArray.size() - 1;
	        while (left < right) {
	            int index = (left + right) / 2;
	            if (rotateArray[index] > rotateArray[right]) {
	                left = index + 1;
	            } else if (rotateArray[index] < rotateArray[right]) {
	                right = index;
	            } else {
	                right--;
	            }
	        }
	
	        return rotateArray[left];
	    }
	};

#### 面试题12：矩阵中的路径 ####

![](https://s3.uuu.ovh/imgs/2023/03/20/e297f05d6e4d8c9f.png#pic_left)

	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     *
	     * @param matrix char字符型vector<vector<>>
	     * @param word string字符串
	     * @return bool布尔型
	     */
	    vector<vector<bool>> isUsed;
	    string path;
	    bool isFind;
	    void backTracking(vector<vector<char>> &matrix, string word, int index, int row, int column)
	    {
	        cout << "row: " << row << " column: " << column << " index: " << index << " word: " << word << endl;
	        cout << "path: " << path << endl;
	        if (index >= word.size()) {
	            if (path == word) {
	                isFind = true;
	            }
	
	            return;
	        }
	
	        if (row > 0 && matrix[row - 1][column] == word[index] &&
	            isUsed[row - 1][column] == false) { // up
	            isUsed[row - 1][column] = true;
	            path += word[index];
	            backTracking(matrix, word, index + 1, row - 1, column);
	            path.pop_back();
	            isUsed[row - 1][column] = false;
	        }
	       
	        if (row < (matrix.size() - 1) && matrix[row + 1][column] == word[index] &&
	            isUsed[row + 1][column] == false) { //down
	            isUsed[row + 1][column] = true;
	            path += word[index];
	            backTracking(matrix, word, index + 1, row + 1, column);
	            path.pop_back();
	            isUsed[row + 1][column] = false;
	        }
	
	        if (column < (matrix[0].size() - 1) && matrix[row][column + 1] == word[index] &&
	            isUsed[row][column + 1] == false) { //right
	            isUsed[row][column + 1] = true;
	            path += word[index];
	            backTracking(matrix, word, index + 1, row, column + 1);
	            path.pop_back();
	            isUsed[row][column + 1] = false;
	        }
	
	        if (column > 0 && matrix[row][column - 1] == word[index] &&
	            isUsed[row][column - 1] == false) { //left
	            isUsed[row][column - 1] = true;
	            path += word[index];
	            backTracking(matrix, word, index + 1, row, column - 1);
	            path.pop_back();
	            isUsed[row][column - 1] = false;
	        }
	    }
	
	    bool hasPath(vector<vector<char> >& matrix, string word) {
	        // write code here
	        if (matrix.size() == 0 || matrix[0].size() == 0) {
	            return false;
	        }
	        isFind = false;
	        vector<bool> tmp(matrix[0].size(), false);
	        isUsed.resize(matrix.size(), tmp);
	        for (int i = 0; i < matrix.size(); i++) {
	            for (int j = 0; j < matrix[0].size(); j++) {
	                if (matrix[i][j] == word[0]) {
	                    // cout << "begin: " << i << "-"<< j << endl;
	                    isUsed[i][j] = true;
	                    path += word[0];
	                    backTracking(matrix, word, 1, i, j);
	                    path.pop_back();
	                    isUsed[i][j] = false;
	                }
	            }
	        }
	
	        return isFind;
	    }
	};



#### 面试题13：机器人的运动范围 ####

![](https://s3.uuu.ovh/imgs/2023/03/20/7da319746c7519dd.png#pic_left)

	class Solution {
	public:
	    vector<vector<bool>> isUsed;
	    int boxNum;
	    int maxRow;
	    int maxCol;
	    bool checkPosition(int threshold, int rows, int cols)
	    {
	        if (rows < 0 || cols < 0 || rows >= maxRow || cols >= maxCol || isUsed[rows][cols] == true) {
	            return false;
	        }
	
	        int sum = 0;
	        while (rows != 0) {
	            sum += rows % 10;
	            rows = rows / 10;
	        }
	
	        while (cols != 0) {
	            sum += cols % 10;
	            cols = cols / 10;
	        }
	
	        if (sum > threshold) {
	            return false;
	        }
	
	        return true;
	    }
	
	    void backTracking(int threshold, int rows, int cols)
	    {
	        if (!checkPosition(threshold, rows, cols)) {
	            return;
	        }
	
	        boxNum++;
	        // cout << "row: " << rows << " cols: " << cols << endl;
	        isUsed[rows][cols] = true;
	        // cout << "2 row: " << rows << " cols: " << cols << endl;
	
	        backTracking(threshold, rows - 1, cols);
	        backTracking(threshold, rows + 1, cols);
	        backTracking(threshold, rows, cols - 1);
	        backTracking(threshold, rows, cols + 1);
	    }
	
	    int movingCount(int threshold, int rows, int cols) {
	        maxRow = rows;
	        maxCol = cols;
	        // cout << rows << " " << cols << endl;
	        vector<bool> tmp(cols, false);
	        isUsed.resize(rows, tmp);
	        backTracking(threshold, 0, 0);
	        // cout << boxNum << endl;
	        return boxNum;
	    }
	};

#### 面试题14：剪绳子 ####

![](https://s3.uuu.ovh/imgs/2023/03/20/b20658b663ea6e7c.png#pic_left)

##### 动态规划解法： #####

	class Solution {
	public:
	    int cutRope(int number) {
	        if (number <= 1) {
	            return 0;
	        } else if (number == 2) {
	            return 1;
	        } else if (number == 3) {
	            return 2;
	        }
	
	        vector<int> dp(number + 1, 0);
	        dp[0] = 0;
	        dp[1] = 1;
	        dp[2] = 2;
	        dp[3] = 3;
	        for (int i = 4; i <= number; i++) {
	            int max = 0;
	            for (int j = 1; j < i; j++) {
	                int value = dp[i - j] * dp[j];
	                if (value > max) {
	                    max = value;
	                }
	            }
	
	            dp[i] = max;
	        }
	
	        return dp[number];
	    }
	};

##### 贪心解法： #####

	class Solution {
	public:
	    int cutRope(int number) {
	        if (number <= 1) {
	            return 0;
	        } else if (number == 2) {
	            return 1;
	        } else if (number == 3) {
	            return 2;
	        }
	
	        int result = 1;
	        while (number > 0) {
	            if (number > 5) {
	                result *= 3;
	                number -= 3;
	            } else if (number == 5) {
	                result *= 6;
	                number -= 5;
	            } else {
	                result *= number;
	                number -= number;
	            }
	        }
	
	        return result;
	    }
	};

#### 面试题15：二进制中1的个数 ####

![](https://s3.uuu.ovh/imgs/2023/03/20/9ee038ade8742ba8.png#pic_left)

	class Solution {
	public:
	    int  NumberOf1(int n) {
	        int oneNum = 0;
	        for (int i = 0; i < 32; i++) {
	            if ((n & (1 << i)) != 0) { // 注意里面的括号，很关键
	                oneNum++;
	            }
	        }
	
	        return oneNum;
	    }
	};


#### 面试题16：数值的整数次方 ####

![](https://s3.uuu.ovh/imgs/2023/03/20/2162ddae0aa01e26.png#pic_left)

	class Solution {
	public:
	    double Power(double base, int exponent) {
	        if (exponent == 0) {
	            return 1;
	        }
	
	        double result = 1.0;
	        bool isNegtive;
	        if (exponent > 0) {
	            isNegtive = false;
	        } else {
	            isNegtive = true;
	            exponent *= -1.0;
	        }
	
	        for (int i = 0; i < exponent; i++) {
	            result *= base;
	        }
	
	        if (isNegtive) {
	            result = 1.0 / result;
	        }
	
	        return result;
	    }
	};

### <a name="chapter3"></a>第三章 高质量的代码

#### 面试题17：打印从1到最大的n位数 ####

![](https://s3.uuu.ovh/imgs/2023/03/20/45c71667a29e9afc.png#pic_left)

	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     *
	     * @param n int整型 最大位数
	     * @return int整型vector
	     */
	    vector<int> printNumbers(int n) {
	        // write code here
	        vector<int> result;
	        int max = 1;
	        for (int i = 0; i < n; i++) {
	            max *= 10;
	        }
	
	        max -= 1;
	        for (int i = 1; i <= max; i++) {
	            result.emplace_back(i);
	        }
	
	        return result;
	    }
	};

#### 面试题18-1：删除链表的节点 ####

![](https://s3.uuu.ovh/imgs/2023/03/21/e20e7a96dbb84856.png#pic_left)

	/**
	 * struct ListNode {
	 *	int val;
	 *	struct ListNode *next;
	 *	ListNode(int x) : val(x), next(nullptr) {}
	 * };
	 */
	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param head ListNode类 
	     * @param val int整型 
	     * @return ListNode类
	     */
	    ListNode* deleteNode(ListNode* head, int val) {
	        // write code here
	        ListNode* preNode = head;
	        ListNode* node = head;
	        if (node->val == val) {
	            node = node->next;
	            preNode->next = nullptr;
	            return node; 
	        } else {
	            node = node->next;
	        }
	
	        while (node) {
	            if (node->val == val) {
	                preNode->next = node->next;
	                delete node;
	                break;
	            } else {
	                preNode = node;
	                node = node->next;
	            }
	        }
	
	        return head;
	    }
	};

#### 面试题18-2：删除链表的节点 ####

![](https://s3.uuu.ovh/imgs/2023/03/21/0a9346d35712372b.png#pic_left)

	/*
	struct ListNode {
	    int val;
	    struct ListNode *next;
	    ListNode(int x) :
	        val(x), next(NULL) {
	    }
	};
	*/
	class Solution {
	public:
	    ListNode* deleteDuplication(ListNode* pHead) {
	        bool isFind = false;
	        ListNode* node = pHead;
	        if (node == nullptr) {
	            return nullptr;
	        }
	
	        while (true) {
	            while (node->next && node->val == node->next->val) {
	                pHead = pHead->next;
	                node = pHead;
	                isFind = true;
	            }
	
	            if (isFind) {
	                pHead = pHead->next;
	                node = pHead;
	                isFind = false;
	            } else {
	                break;
	            }
	
	            if (node == nullptr) {
	                return nullptr;
	            }
	        }
	        
	        ListNode* pre = node;
	        while(node->next) {
	            while (node->next && node->val == node->next->val) {
	                pre->next = node->next;
	                node = node->next;
	                isFind = true;
	            }
	
	            if (isFind) {
	                pre->next = node->next;
	                node = node->next;
	                isFind = false;
	                if (node == nullptr) {
	                    break;
	                }
	            } else {
	                pre = node;
	                node = node->next;
	            }
	        }
	
	        return pHead;
	    }
	};

#### <font color="#0000dd">面试题19：正则表达式匹配</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/03/21/4a2671c469db895e.png)

	class Solution {
	    bool matchCore(const string& str,const string& pattern){
	        if(str.empty()&&pattern.empty())
	            return true;
	        if(!str.empty()&&pattern.empty())
	            return false;
	        if(pattern[1]=='*'){
	            if(pattern[0]==str[0]||(pattern[0]=='.'&&!str.empty()))
	                                //进入下一状态
	                return matchCore(str.substr(1),pattern.substr(2))
	                                //留在当前状态
	                                ||matchCore(str.substr(1), pattern)
	                                //忽略一个'*'
	                                ||matchCore(str, pattern.substr(2));
	            else
	                                //忽略一个'*'
	                return matchCore(str, pattern.substr(2));
	        }
	        if(str[0]==pattern[0]||(pattern[0]=='.'&&!str.empty()))
	            return matchCore(str.substr(1), pattern.substr(1));
	        
	        return false;
	    }
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param str string字符串 
	     * @param pattern string字符串 
	     * @return bool布尔型
	     */
	    bool match(string str, string pattern) {
	        // write code here
	        return matchCore(str,pattern);
	    }
	};

#### <font color="#0000dd">面试题20：表示数值的字符串</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/03/22/9bd8044402f878f0.png)

	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param str string字符串 
	     * @return bool布尔型
	     */
	    bool isUnsigned(string str, int &index)
	    {
	        if (index >= str.size()) {
	            return false;
	        }
	
	        int begin = index;
	        while (str[index] == ' ' || str[index] >= '0' && str[index] <= '9') {
	            if (str[index] == ' ') {
	                begin++;
	            }
	            cout << str[index] << endl;
	            index++;
	        }
	
	        return (index > begin);
	    }
	
	    bool isInterger(string str, int &index)
	    {
	        int begin = index;
	        while (str[index] == ' ' || str[index] == '+' || str[index] == '-') {
	            if (str[index] == ' ') {
	                begin++;
	            }
	
	            index++;
	        }
	
	        if ((index - begin) > 1) {
	            return false;
	        }
	
	        return (isUnsigned(str, index));
	    }
	
	    bool isNumeric(string str) {
	        // write code here
	        // A[.[B]][e|EC] || .[B][e|EC]
	        if (str.size() == 0) {
	            return false;
	        }
	
	        int index = 0;
	        bool result = isInterger(str, index);
	        if (index < str.size() && str[index] == '.') {
	            index++;
	            result = isUnsigned(str, index) || result;
	        }
	
	        if (index < str.size() && result && (str[index] == 'e' || str[index] == 'E')) {
	            index++;
	            if (index >= str.size()) {
	                result = false;
	            } else {
	                result = isInterger(str, index);
	            }
	        }
	
	        return result && (index == str.size());
	    }
	};

#### 面试题21：调整数组顺序使奇数位于偶数前面 ####

![](https://s3.uuu.ovh/imgs/2023/03/22/d5e16023d1d42fa4.png)

	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param array int整型vector 
	     * @return int整型vector
	     */
	    vector<int> reOrderArray(vector<int>& array) {
	        // write code here
	        vector<int> result;
	        for (int i = 0; i < array.size(); i++) {
	            int num = array[i] % 10;
	            if (num == 1 || num == 3 || num == 5 || num == 7 || num == 9) {
	                result.emplace_back(array[i]);
	            }
	        }
	
	        for (int i = 0; i < array.size(); i++) {
	            int num = array[i] % 10;
	            if (num == 0 || num == 2 || num == 4 || num == 6 || num == 8) {
	                result.emplace_back(array[i]);
	            }
	        }
	
	        return result;
	    }
	};

	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param array int整型vector 
	     * @return int整型vector
	     */
	    vector<int> reOrderArray(vector<int>& array) {
	        // write code here
	        int index = 0;
	        int i = 0;
	        while (i < array.size() - index) {
	            if ((array[i] & 0x1) == 0) {
	                int num = array[i];
	                for (int j = i; j < array.size() - 1; j++) {
	                    array[j] = array[j + 1];
	                }
	
	                array[array.size() - 1] = num;
	                index++;
	            } else {
	                i++;
	            }
	        }
	
	        return array;
	    }
	};

#### 面试题22：链表中倒数最后k个节点 ####

![](https://s3.uuu.ovh/imgs/2023/03/22/d64b5610beff634c.png)

	/**
	 * struct ListNode {
	 *	int val;
	 *	struct ListNode *next;
	 *	ListNode(int x) : val(x), next(nullptr) {}
	 * };
	 */
	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param pHead ListNode类 
	     * @param k int整型 
	     * @return ListNode类
	     */
	    ListNode* FindKthToTail(ListNode* pHead, int k) {
	        // write code here
	        if (pHead == nullptr || k == 0) {
	            return nullptr;
	        }
	
	        ListNode *left = pHead;
	        ListNode *right = pHead;
	        while (k > 1) {
	            right = right->next;
	            if (right == nullptr) {
	                return nullptr;
	            }
	
	            k--;
	        }
	
	        while (right->next) {
	            left = left->next;
	            right = right->next;
	        }
	
	        return left;
	    }
	};

#### <font color="#0000dd">面试题23：链表中环的入口节点</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/03/23/31e39167e94c4fe7.png)

	/*
	struct ListNode {
	    int val;
	    struct ListNode *next;
	    ListNode(int x) :
	        val(x), next(NULL) {
	    }
	};
	*/
	class Solution {
	public:
	    ListNode* EntryNodeOfLoop(ListNode* pHead) {
	        if (pHead == nullptr) {
	            return nullptr;
	        }
	
	        ListNode *fast = pHead;
	        ListNode *slow = pHead;
	        while (true) {
	            slow = slow->next;
	            if (!slow) {
	                return nullptr;
	            }
	
	            fast = fast->next->next;
	            if (!fast) {
	                return nullptr;
	            }
	
	            if (slow == fast) {
	                cout << slow->val << endl;
	                break;
	            }
	        }
	
	        ListNode *node = pHead;
	        while (true) {
	            if (slow == node) {
	                cout << node->val << endl;
	                break;
	            }
	
	            node = node->next;
	            slow = slow->next;
	        }
	
	        return node;
	    }
	};

#### 面试题24：反转链表 ####

![](https://s3.uuu.ovh/imgs/2023/03/22/576e0d5fb02feca0.png)

	/*
	struct ListNode {
		int val;
		struct ListNode *next;
		ListNode(int x) :
				val(x), next(NULL) {
		}
	};*/
	class Solution {
	public:
	    ListNode* ReverseList(ListNode* pHead) {
			if (pHead == nullptr || pHead->next == nullptr) {
				return pHead;
			}
	
			ListNode *next = pHead->next;
			ListNode *tempNode = next->next;
			pHead->next = nullptr;
			next->next = pHead;
			ListNode *pre = next;
			next = tempNode;
	
			while (next) {
				ListNode *temp = next->next;
				next->next = pre;
				pre = next;
				next = temp;
			}
	
			return pre;
	    }
	};

#### <font color="#0000dd">面试题25：合并两个排序的链表</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/03/24/ec5516071d31bf58.png)

	/*
	struct ListNode {
		int val;
		struct ListNode *next;
		ListNode(int x) :
				val(x), next(NULL) {
		}
	};*/
	class Solution {
	public:
	    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
	        if (!pHead1) {
				return pHead2;
			} else if (!pHead2) {
				return pHead1;
			}
	
			ListNode *node1 = pHead1;
			ListNode *node2 = pHead2;
			ListNode *head = nullptr;
			if (pHead1->val <= pHead2->val) {
				head = pHead1;
				node1 = pHead1->next;
			} else {
				head = pHead2;
				node2 = pHead2->next;
			}
	
			ListNode *node = head;
			while (node1 || node2) {
				if (!node1) {
					node->next = node2;
					break;
				} else if (!node2) {
					node->next = node1;
					break;
				}
	
				if (node1->val <= node2->val) {
					node->next = node1;
					node1 = node1->next;
				} else {
					node->next = node2;
					node2 = node2->next;
				}
	
				node = node->next;
			}
	
			return head;
	    }
	};


#### 面试题26：树的子结构 ####

![](https://s3.uuu.ovh/imgs/2023/03/24/96af247f4d314817.png)

	/*
	struct TreeNode {
		int val;
		struct TreeNode *left;
		struct TreeNode *right;
		TreeNode(int x) :
				val(x), left(NULL), right(NULL) {
		}
	};*/
	class Solution {
	public:
		bool result;
		bool isSameTree(TreeNode* node1, TreeNode* node2) {
			if (node2 != nullptr && node1 == nullptr) {
				return false;
			}
	
			if (node2 == nullptr) {
				return true;
			}
	
			bool isSameLeft = false;
			bool isSameRight = false;
			if (node1->val == node2->val) {
				isSameLeft = isSameTree(node1->left, node2->left);
				isSameRight = isSameTree(node1->right, node2->right);
			}
	
			return (isSameLeft && isSameRight);
		}
	
		void preOrder(TreeNode* node, TreeNode* pRoot2)
		{
			if (result || node == nullptr || pRoot2 == nullptr) {
				return;
			}
	
			if (node->val == pRoot2->val) {
				result = isSameTree(node, pRoot2);
			}
	
			preOrder(node->left, pRoot2);
			preOrder(node->right, pRoot2);
		}
	
	    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {
			result = false;
			preOrder(pRoot1, pRoot2);
			return result;
	    }
	};

### <a name="chapter4"></a>第四章 解决面试题的思路

#### 面试题27：二叉树的镜像 ####

![](https://s3.uuu.ovh/imgs/2023/03/24/9471a84604b0a69e.png)

	/**
	 * struct TreeNode {
	 *	int val;
	 *	struct TreeNode *left;
	 *	struct TreeNode *right;
	 *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
	 * };
	 */
	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param pRoot TreeNode类 
	     * @return TreeNode类
	     */
	    void MirrorInternal(TreeNode* node)
	    {
	        if (node == nullptr) {
	            return;
	        }
	
	        TreeNode* temp = node->left;
	        node->left = node->right;
	        node->right = temp;
	        MirrorInternal(node->left);
	        MirrorInternal(node->right);
	    }
	
	    TreeNode* Mirror(TreeNode* pRoot) {
	        // write code here
	        MirrorInternal(pRoot);
	        return pRoot;
	    }
	};

#### 面试题28：对称二叉树 ####

![](https://s3.uuu.ovh/imgs/2023/03/24/b9ebda534da4faa4.png)


	/*
	struct TreeNode {
	    int val;
	    struct TreeNode *left;
	    struct TreeNode *right;
	    TreeNode(int x) :
	            val(x), left(NULL), right(NULL) {
	    }
	};
	*/
	class Solution {
	public:
	    bool result;
	    void preOrder(TreeNode *node1, TreeNode *node2)
	    {
	        if (!result || node1 == nullptr && node2 == nullptr) {
	            return;
	        }
	
	        if (node1 == nullptr || node2 == nullptr) {
	            result = false;
	            return;
	        }
	
	        if (node1->val != node2->val) {
	            result = false;
	            return;
	        }
	        preOrder(node1->left, node2->right);
	        preOrder(node1->right, node2->left);
	    }
	
	    bool isSymmetrical(TreeNode* pRoot) {
	        result = true;
	        preOrder(pRoot, pRoot);
	        return result;
	    }
	
	};

#### 面试题29：顺时针打印矩阵 ####

![](https://s3.uuu.ovh/imgs/2023/03/26/5f698399fed650f2.png)

	class Solution {
	public:
	    vector<int> result;
	    void printOneCircle(vector<vector<int>> matrix, int times)
	    {
	        // 从左到右（外扩）
	        for (int i = times; i < matrix[0].size() - times; i++) {
	            result.emplace_back(matrix[times][i]);
	        }
	
	        // 从上到下（内缩）
	        for (int i = times + 1; i < matrix.size() - times - 1; i++) {
	            result.emplace_back(matrix[i][matrix[0].size() - 1 - times]);
	        }
	
	        // 从右到左（外扩）
	        for (int i = matrix[0].size() - 1 - times; i >= times; i--) {
	            if (matrix.size() - 1 - times == times) { // 同一行去重
	                break;
	            }
	            result.emplace_back(matrix[matrix.size() - 1 - times][i]);
	        }
	        
	        // 从下到上（内缩）
	        for (int i = matrix.size() - 2 - times; i > times; i--) {
	            if (matrix[0].size() - 1 - times == times) { // 同一列去重
	                break;
	            }
	            result.emplace_back(matrix[i][times]);
	        }
	    }
	
	    vector<int> printMatrix(vector<vector<int>> matrix) {
	        int times = 0;
	        while (result.size() != matrix.size() * matrix[0].size()) {
	            printOneCircle(matrix, times);
	            times++;
	        }
	
	        return result;
	    }
	};

#### <font color="#0000dd">面试题30：包含min函数的栈</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/03/26/9398107bb1403a0e.png)

	class Solution {
	public:
	    stack<int> minStack;
	    stack<int> valStack;
	
	    void push(int value) {
	        valStack.push(value);
	        if (minStack.empty()) {
	            minStack.push(value);
	        } else {
	            int minVal = minStack.top();
	            if (minVal > value) {
	                minVal = value;
	            }  
	
	            minStack.push(minVal);
	        }
	    }
	
	    void pop() {
	        minStack.pop();
	        valStack.pop();
	    }
	
	    int top() {
	        return valStack.top();    
	    }
	
	    int min() {
	        return minStack.top();
	    }
	};

#### 面试题31：栈的压入、弹出序列 ####

![](https://s3.uuu.ovh/imgs/2023/03/26/9612b1894f64b870.png)

	class Solution {
	public:
	    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
	        stack<int> stk;
	        int pushIndex = 0;
	        int popIndex = 0;
	        while (pushIndex <= pushV.size()) {
	            if (stk.empty()) {
	                if (pushIndex >= pushV.size()) {
	                    break;
	                }
	                stk.push(pushV[pushIndex]);
	                pushIndex++;
	            }
	
	            if (stk.top() == popV[popIndex]) {
	                stk.pop();
	                popIndex++;
	            } else {
	                if (pushIndex >= pushV.size()) {
	                    break;
	                }
	                stk.push(pushV[pushIndex]);
	                pushIndex++;
	            }
	        }
	
	        cout << popIndex << endl;
	        return (popV.size() == popIndex);
	    }
	};

#### 面试题32-1：从上往下打印二叉树 ####

![](https://s3.uuu.ovh/imgs/2023/03/26/a2224d925a397ead.png)

	/*
	struct TreeNode {
	    int val;
	    struct TreeNode *left;
	    struct TreeNode *right;
	    TreeNode(int x) :
	            val(x), left(NULL), right(NULL) {
	    }
	};*/
	class Solution {
	public:
	    vector<int> PrintFromTopToBottom(TreeNode* root) {
	        vector<int> result;
	        queue<TreeNode*> nodeQue;
	        if (root != nullptr) {
	            nodeQue.push(root);
	        }

	        while (!nodeQue.empty()) {
	            int queueSize = nodeQue.size();
	            for (int i = 0; i < queueSize; i++) {
	                TreeNode *tempNode = nodeQue.front();
	                nodeQue.pop();
	                result.emplace_back(tempNode->val);
	                if (tempNode->left) {
	                    nodeQue.push(tempNode->left);
	                }
	
	                if (tempNode->right) {
	                    nodeQue.push(tempNode->right);
	                }
	            }
	        }

	        return result;
	    }
	};

#### 面试题32-2：按之字形打印二叉树 ####

![](https://s3.uuu.ovh/imgs/2023/03/27/1f3e81875eb0bfbb.png)

	/*
	struct TreeNode {
	    int val;
	    struct TreeNode *left;
	    struct TreeNode *right;
	    TreeNode(int x) :
	            val(x), left(NULL), right(NULL) {
	    }
	};
	*/
	class Solution {
	public:
	    vector<vector<int>> result;
	    vector<vector<int> > Print(TreeNode* pRoot) {
	        queue<TreeNode*> nodeQue;
	        if (pRoot != nullptr) {
	            nodeQue.push(pRoot);
	        }
	
	        int flag = 1;
	        while (!nodeQue.empty()) {
	            int queueSize = nodeQue.size();
	            vector<int> path;
	            for (int i = 0; i < queueSize; i++) {
	                TreeNode *node = nodeQue.front();
	                nodeQue.pop();
	                path.emplace_back(node->val);
	                if (node->left) {
	                    nodeQue.push(node->left);
	                }
	
	                if (node->right) {
	                    nodeQue.push(node->right);
	                }
	            }
	
	            if (flag > 0) {
	                result.emplace_back(path);
	            } else {
	                reverse(path.begin(), path.end());
	                result.emplace_back(path);
	            }
	
	            flag *= -1;
	        }
	
	        return result;
	    }
	    
	};

#### 面试题33：二叉搜索树的后序遍历序列 ####

![](https://s3.uuu.ovh/imgs/2023/03/28/8879135b3d63fbfe.png)

	class Solution {
	public:
	    bool isBST(vector<int> nums)
	    {
	        if (nums.size() == 0) {
	            return true;
	        }
	
	        int node = nums[nums.size() - 1];
	        int index = -1;
	        for (int i = 0; i < nums.size(); i++) {
	            if (nums[i] > node) {
	                index = i;
	                break;
	            }
	        }
	
	        for (int i = index; (i >= 0 && i < nums.size()); i++) {
	            if (nums[i] < node) {
	                return false;
	            }
	        }
	
	        if (index < 0) {
	            index = 0;
	        }
	
	        vector<int> left(nums.begin(), nums.begin() + index);
	        vector<int> right(nums.begin() + index, nums.end() - 1);
	        bool leftIsBST = isBST(left);
	        bool rightIsBST = isBST(right);
	        return (leftIsBST && rightIsBST);
	    }
	
	    bool VerifySquenceOfBST(vector<int> sequence) {
	        if (sequence.size() == 0) {
	            return false;
	        }
	
	        bool result = isBST(sequence);
	        return result;
	    }
	};

#### 面试题34：二叉树中和为某一值的路径 ####

![](https://s3.uuu.ovh/imgs/2023/03/28/44b035aa964787c6.png)

	/*
	struct TreeNode {
		int val;
		struct TreeNode *left;
		struct TreeNode *right;
		TreeNode(int x) :
				val(x), left(NULL), right(NULL) {
		}
	};*/
	#include <numeric>
	class Solution {
	public:
		vector<vector<int>> result;
		vector<int> path;
		void preOrder(TreeNode *node, int expectNumber)
		{
			if (node == nullptr) {
				return;
			}
		
			path.emplace_back(node->val);
			if (node->left) {
				preOrder(node->left, expectNumber);
			}
		
			if (node->right) {
				preOrder(node->right, expectNumber);
			}
		
			if (!node->left && !node->right) {
				if (!path.empty()) {;
					if (accumulate(path.begin(), path.end(), 0) == expectNumber) {
						result.emplace_back(path);
					}
				}
			}
		
			path.pop_back();
		}
		vector<vector<int>> FindPath(TreeNode* root,int expectNumber) {
		    preOrder(root, expectNumber);
			return result;
		}
	};

#### <font color="#0000dd">面试题35：复杂链表的复制</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/03/29/62463c6ca0a47814.png)

	/*
	struct RandomListNode {
	    int label;
	    struct RandomListNode *next, *random;
	    RandomListNode(int x) :
	            label(x), next(NULL), random(NULL) {
	    }
	};
	*/
	class Solution {
	public:
	    RandomListNode* Clone(RandomListNode* pHead) {
	        unordered_map<RandomListNode*, RandomListNode*> listHash;
	        RandomListNode *node = pHead;
	        RandomListNode *newHead = nullptr;
	        RandomListNode *preNewNode = nullptr;
	        while (node) {
	            RandomListNode *newNode = new RandomListNode(node->label);
	            listHash[node] = newNode;
	            node = node->next;
	
	            if (!newHead) {
	                newHead = newNode;
	                preNewNode = newNode;
	            } else {
	                preNewNode->next = newNode;
	                preNewNode = newNode;
	            }
	        }
	
	        node = pHead;
	        RandomListNode *newNode = newHead;
	        while (node) {
	            RandomListNode *randNode = node->random;
	            if (randNode) {
	                randNode = listHash[randNode];
	                newNode->random = randNode;
	            }
	
	            node = node->next;
	            newNode = newNode->next;
	        }
	
	        return newHead;
	    }
	};

#### 面试题36：二叉搜索树与双向链表 ####

![](https://s3.uuu.ovh/imgs/2023/03/30/da03d3896bdb0c54.png)

	/*
	struct TreeNode {
	    int val;
	    struct TreeNode *left;
	    struct TreeNode *right;
	    TreeNode(int x) :
	            val(x), left(NULL), right(NULL) {
	    }
	};*/
	class Solution {
	public:
	    vector<TreeNode*> nums;
	    TreeNode* preNode;
	    TreeNode* head;
	
	    void inOrder(TreeNode* node)
	    {
	        if (node == nullptr) {
	            return;
	        }
	
	        inOrder(node->left);
	        if (head == nullptr) {
	            head = node;
	        }
	
	        if (preNode) {
	            preNode->right = node;
	            node->left = preNode;
	        }
	
	        nums.emplace_back(node);
	        preNode = node;
	        inOrder(node->right);
	    }
	
	    TreeNode* Convert(TreeNode* pRootOfTree) {
	        head = nullptr;
	        preNode = nullptr;
	        inOrder(pRootOfTree);
	        return head;
	    }
	};

#### <font color="#0000dd">面试题37：序列化二叉树</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/03/31/c1247d9fb7723df0.png)

	/*
	struct TreeNode {
	    int val;
	    struct TreeNode *left;
	    struct TreeNode *right;
	    TreeNode(int x) :
	            val(x), left(NULL), right(NULL) {
	    }
	};
	*/
	class Solution {
	public:
	    
	    char* Serialize(TreeNode *root) {
	        string result;
	        queue<TreeNode*> nodeQue;
	        if (root) {
	            nodeQue.push(root);
	        }
	
	        while (!nodeQue.empty()) {
	            int queueSize = nodeQue.size();
	            for (int i = 0; i < queueSize; i++) {
	                TreeNode *node = nodeQue.front();
	                nodeQue.pop();
	                if (node == nullptr) {
	                    result += '#';
	                    continue;
	                } else {
	                    result += to_string(node->val) + ',';
	                }
	
	                nodeQue.push(node->left);
	                nodeQue.push(node->right);
	            }
	        }
	
	        if (result.size() == 0) {
	            return nullptr;
	        }
	
	        char *serializeArray = new char[result.size() + 1];
	        strcpy(serializeArray, result.c_str());
	        return serializeArray;
	    }
	
	    TreeNode* Deserialize(char *str) {
	        if (str == nullptr) {
	            return nullptr;
	        }
	
	        string data = string(str);
	        vector<string> nums;
	        for (int i = 0; i < data.size(); i++) {
	            if (data[i] == '#') {
	                nums.emplace_back("#");
	            } else {
	                int endIndex = i;
	                while (data[endIndex] != ',') {
	                    endIndex++;
	                }
	
	                nums.emplace_back(data.substr(i, endIndex - i));
	                i = endIndex;
	            }
	        }
	
	        queue<TreeNode*> nodeQue;
	        TreeNode *node = new TreeNode(stoi(nums[0]));
	        TreeNode *head = node;
	        nodeQue.push(node);
	        int numIndex = 1;
	        while (!nodeQue.empty()) {
	            int queueSize = nodeQue.size();
	            for (int i = 0; i < queueSize; i++) {
	                TreeNode *tempNode = nodeQue.front();
	                nodeQue.pop();
	                for (int j = 0; j < 2; j++) {
	                    if (nums[numIndex] == "#") {
	                        numIndex++;
	                    } else {
	                        node = new TreeNode(stoi(nums[numIndex]));
	                        nodeQue.push(node);
	                        if (j == 0) {
	                            tempNode->left = node;
	                        } else {
	                            tempNode->right = node;
	                        }
	
	                        numIndex++;
	                    }
	                }
	            }
	        }
	
	        return head;
	    }
	};

### <a name="chapter5"></a>第五章

    第五章内容

### <a name="chapter6"></a>第六章

    第六章内容

### <a name="chapter7"></a>第七章

    第七章内容

### <a name="chapter8"></a>第八章

    第八章内容

### 参考资源

* [nowcoder](https://www.nowcoder.com/exam/oj/ta?page=1&tpId=13&type=13)

转载请注明：[sizheluo的博客](https://sizheluo.github.io) » [JZ_Note](https://sizheluo.github.io/2023/03/JZ_Note/)