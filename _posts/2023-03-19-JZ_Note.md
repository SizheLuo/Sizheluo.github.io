---
layout: post
title: "2023-03-19-JZ_Note"
date: 2023-03-19
description: "JZ算法题"
tag: 算法
---

### 前言

	`JZ算法题记录。`

### 目录

* [第一章](#chapter1)
* [第二章](#chapter2)
* [第三章](#chapter3)
* [第四章](#chapter4)
* [第五章](#chapter5)
* [第六章](#chapter6)
* [第七章](#chapter7)
* [第八章](#chapter8)

### <a name="chapter1"></a>第一章

    第一章内容

### <a name="chapter2"></a>第二章 面试需要的基础知识

#### 前置知识 ####

一、关于sizeof
定义一个空类型，求sizeof得到的结果是1。空实例不包含任何信息 ，但必须在内存中占有一定的空间，否则无法使用这些实例。
再添加一个构造函数和析构函数，sizeof的结果还是1。调用构造函数只需要知道函数的地址即可，而这些函数的地址只与类型相关，而与类型的实例无关。
把析构函数标记为虚函数，sizeof的值为4或者8，为指针占用空间，会生成虚函数表，并在类的每一个实例中添加一个指向虚函数的指针。

#### 面试题1：赋值运算符函数 ####

#### 面试题2：实现Singleton模式，设计一个类，我们只能生成该类的一个实例 ####

#### 面试题3：数组中重复的数字 ####

在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。
也不知道每个数字重复几次。请找出数组中第一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，
那么对应的输出是第一个重复的数字2。
返回描述：
如果数组中有重复的数字，函数返回true，否则返回false。
如果数组中有重复的数字，把重复的数字放到参数duplication[0]中。（ps:duplication已经初始化，可以直接赋值使用。）

    class Solution {
    public:
	    bool duplicate(int numbers[], int length, int* duplication) {
	    	bool haveDuplication;
	    	int index = 0;
	    	vector<int> hashTable(length, -1);
	    	for (int i = 0; i < length; i++) {
		    	if (hashTable[numbers[i]] == -1) {
		    		hashTable[numbers[i]] = numbers[i];
		    	} else if (hashTable[numbers[i]] == numbers[i]) {
		    		duplication[index] = numbers[i];
				    index++;
				    break;
		    	}
	    	}
	    
		    if (index == 0) {
		    	haveDuplication = false;
		    } else {
		    	haveDuplication = true;
		    }
	    
	    	return haveDuplication;
	    }
    };

#### 面试题4： 二维数组中的查找 ####

在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
[
[1,2,8,9],
[2,4,9,12],
[4,7,10,13],
[6,8,11,15]
]
给定 target = 7，返回 true。
给定 target = 3，返回 false。

	class Solution {
	public:
	    int rightAndUp(int row, int column, vector<vector<int>> array)
	    {
	        return array[row][column];
	    }
	
	    bool Find(int target, vector<vector<int> > array) {
	        if (array.size() == 0 || array[0].size() == 0) {
	            return false;
	        }
	
	        int row = 0;
	        int column = array[0].size() - 1;
	        int value = array[row][column];
	        bool isFind = false;
	        while (true) {
	            cout << value << endl;
	            if (value > target) {
	                column--;
	            } else if (value < target) {
	                row++;
	            } else {
	                isFind = true;
	                break;
	            }
	
	            if (row == array.size() || column < 0) {
	                break;
	            } else {
	                value = rightAndUp(row, column, array);
	            }
	        }
	       
	        return isFind;
	    }
	};

#### 面试题5：替换空格 ####

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

	class Solution {
	public:
	    void replaceSpace(char *str,int length) {
	        int spaceNum = 0;
	        for (int i = 0; i < length; i++) {
	            if (str[i] == ' ') {
	                spaceNum++;
	            }
	        }
	
	        int paddingLen = 2 * spaceNum;
	        for (int i = (length + paddingLen), j = length; i >= 0 && j >= 0;) {
	            if (str[j] == ' ') {
	                str[i] = '0';
	                i--;
	                str[i] = '2';
	                i--;
	                str[i] = '%';
	                i--;
	                j--;
	            } else {
	                str[i] = str[j];
	                i--;
	                j--;
	            }
	        }
	
	        return;
	    }
	};

#### 面试题6：从尾到头打印链表 ####

输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。
如输入{1,2,3}的链表如下图:

![](https://s3.uuu.ovh/imgs/2023/03/20/17883538d3b8dd23.png#pic_left)

返回一个数组为[3,2,1]
0 <= 链表长度 <= 10000

	/**
	*  struct ListNode {
	*      int val;
	*      struct ListNode *next;
	*       ListNode(int x) :
	*           val(x), next(NULL) {
	*       }
	*  };
	*/

	class Solution {
	public:
	vector<int> result;
	void printListReverse(ListNode *node) {
	if (node != nullptr) {
	printListReverse(node->next);
	result.emplace_back(node->val);
	}
	
	return;
	}
	
	vector<int> printListFromTailToHead(ListNode* head) {
	printListReverse(head);
	return result;
	}
	};

#### 面试题7：重建二叉树 ####

给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。
例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。

![](https://s3.uuu.ovh/imgs/2023/03/20/af00cbaa1f1630c3.png#pic_left)

提示:1. vin.length == pre.length
2. pre 和 vin 均无重复元素
3. vin出现的元素均出现在 pre里
4. 只需要返回根结点，系统会自动输出整颗树做答案对比
5. 要求：空间复杂度 O(n)，时间复杂度 O(n)

	/**
	 * Definition for binary tree
	 * struct TreeNode {
	 *     int val;
	 *     TreeNode *left;
	 *     TreeNode *right;
	 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
	 * };
	 */
	class Solution {
	public:
	    TreeNode* reConstructInternal(vector<int> pre, vector<int> vin)
	    {
	        if (pre.size() == 0 || vin.size() == 0) {
	            return nullptr;
	        }
	
	        TreeNode *node = new TreeNode(pre[0]);
	        int indexInVin = 0;
	        for (int i = 0; i < vin.size(); i++) {
	            if (pre[0] == vin[i]) {
	                indexInVin = i;
	                break;
	            }
	        }
	
	        vector<int> leftPre(pre.begin() + 1, pre.begin() + 1 + indexInVin);
	        vector<int> rightPre(pre.begin() + 1 + indexInVin, pre.end());
	
	        vector<int> leftVin(vin.begin(), vin.begin() + indexInVin);
	        vector<int> rightVin(vin.begin() + indexInVin + 1, vin.end());
	
	        node->left = reConstructInternal(leftPre, leftVin);
	        node->right = reConstructInternal(rightPre, rightVin);
	
	        return node;
	    }
	
	    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
	        TreeNode *root = reConstructInternal(pre, vin);
	        return root;
	    }
};

#### <font color="#0000dd">面试题8：重建二叉树描述</font><br /> ####

给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。下图为一棵有9个节点的二叉树。树中从父节点指向子节点的指针用实线表示，从子节点指向父节点的用虚线表示

![](https://s3.uuu.ovh/imgs/2023/03/20/6edf66e09fa2f118.png#pic_left)

	/*
	struct TreeLinkNode {
	    int val;
	    struct TreeLinkNode *left;
	    struct TreeLinkNode *right;
	    struct TreeLinkNode *next;
	    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) {
	       
	    }
	};
	*/
	class Solution {
	public:
	    TreeLinkNode* GetNext(TreeLinkNode* pNode) {
	        if (pNode == nullptr) {
	            return nullptr;
	        }
	
	        if (pNode->right != nullptr) { // 第一种情况，存在右子树
	            if (pNode->right->left == nullptr) {
	                return pNode->right;
	            } else {
	                TreeLinkNode *node = pNode->right;
	                while (node->left) {
	                    node = node->left;
	                }
	
	                return node;
	            }
	        } else {
	            if (pNode->next == nullptr) {
	                return nullptr;
	            } else if (pNode->next->left == pNode) {  // 第二种情况，不存在右子树且为父节点左子书
	                return pNode->next;
	            } else { // 第三种情况，不存在左子树且为父节点的右子树
	                TreeLinkNode *node = pNode->next;
	                TreeLinkNode *result = nullptr;
	                while (node->next) {
	                    if (node == node->next->left) {
	                        result = node->next;
	                        break;
	                    }
	
	                    node = node->next;
	                }
	
	                return result;
	            }
	        }
	    }
	};

#### 面试题9：用两个栈实现队列 ####

用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。

数据范围： n≤1000
要求：存储n个元素的空间复杂度为 O(n) ，插入与删除的时间复杂度都是 O(1)

	class Solution
	{
	public:
	    void push(int node) {
	        if (stack1.empty() && stack2.empty()) {
	            stack1.push(node);
	        } else if (!stack1.empty()) {
	            stack1.push(node);
	        } else {
	            stack1.push(node);
	        }
	    }
	
	    int pop() {
	        if (stack2.empty() && !stack1.empty()) {
	            int val;
	            while (!stack1.empty()) {
	                val = stack1.top();
	                stack1.pop();
	                stack2.push(val);
	            }
	
	            val = stack2.top();
	            stack2.pop();
	            return val;
	        } else {
	            int val = stack2.top();
	            stack2.pop();
	            return val;
	        }
	    }
	
	private:
	    stack<int> stack1;
	    stack<int> stack2;
	};

#### 面试题10：斐波那契数列 ####

	class Solution {
	public:
	    int Fibonacci(int n) {
	        if (n == 1 || n == 2) {
	            return 1;
	        } else {
	            return Fibonacci(n - 1) + Fibonacci(n - 2);
	        }
	    }
	};


#### <font color="#0000dd">面试题11：旋转数组的最小数字</font><br /> ####

有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。
数据范围：1≤n≤10000，数组中任意元素的值: 0≤val≤10000
要求：空间复杂度：O(1) ，时间复杂度：O(logn)

	class Solution {
	public:
	    int minNumberInRotateArray(vector<int> rotateArray) {
	        int left = 0;
	        int right = rotateArray.size() - 1;
	        while (left < right) {
	            int index = (left + right) / 2;
	            if (rotateArray[index] > rotateArray[right]) {
	                left = index + 1;
	            } else if (rotateArray[index] < rotateArray[right]) {
	                right = index;
	            } else {
	                right--;
	            }
	        }
	
	        return rotateArray[left];
	    }
	};

#### 面试题12：矩阵中的路径 ####

![](https://s3.uuu.ovh/imgs/2023/03/20/e297f05d6e4d8c9f.png#pic_left)

	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     *
	     * @param matrix char字符型vector<vector<>>
	     * @param word string字符串
	     * @return bool布尔型
	     */
	    vector<vector<bool>> isUsed;
	    string path;
	    bool isFind;
	    void backTracking(vector<vector<char>> &matrix, string word, int index, int row, int column)
	    {
	        cout << "row: " << row << " column: " << column << " index: " << index << " word: " << word << endl;
	        cout << "path: " << path << endl;
	        if (index >= word.size()) {
	            if (path == word) {
	                isFind = true;
	            }
	
	            return;
	        }
	
	        if (row > 0 && matrix[row - 1][column] == word[index] &&
	            isUsed[row - 1][column] == false) { // up
	            isUsed[row - 1][column] = true;
	            path += word[index];
	            backTracking(matrix, word, index + 1, row - 1, column);
	            path.pop_back();
	            isUsed[row - 1][column] = false;
	        }
	       
	        if (row < (matrix.size() - 1) && matrix[row + 1][column] == word[index] &&
	            isUsed[row + 1][column] == false) { //down
	            isUsed[row + 1][column] = true;
	            path += word[index];
	            backTracking(matrix, word, index + 1, row + 1, column);
	            path.pop_back();
	            isUsed[row + 1][column] = false;
	        }
	
	        if (column < (matrix[0].size() - 1) && matrix[row][column + 1] == word[index] &&
	            isUsed[row][column + 1] == false) { //right
	            isUsed[row][column + 1] = true;
	            path += word[index];
	            backTracking(matrix, word, index + 1, row, column + 1);
	            path.pop_back();
	            isUsed[row][column + 1] = false;
	        }
	
	        if (column > 0 && matrix[row][column - 1] == word[index] &&
	            isUsed[row][column - 1] == false) { //left
	            isUsed[row][column - 1] = true;
	            path += word[index];
	            backTracking(matrix, word, index + 1, row, column - 1);
	            path.pop_back();
	            isUsed[row][column - 1] = false;
	        }
	    }
	
	    bool hasPath(vector<vector<char> >& matrix, string word) {
	        // write code here
	        if (matrix.size() == 0 || matrix[0].size() == 0) {
	            return false;
	        }
	        isFind = false;
	        vector<bool> tmp(matrix[0].size(), false);
	        isUsed.resize(matrix.size(), tmp);
	        for (int i = 0; i < matrix.size(); i++) {
	            for (int j = 0; j < matrix[0].size(); j++) {
	                if (matrix[i][j] == word[0]) {
	                    // cout << "begin: " << i << "-"<< j << endl;
	                    isUsed[i][j] = true;
	                    path += word[0];
	                    backTracking(matrix, word, 1, i, j);
	                    path.pop_back();
	                    isUsed[i][j] = false;
	                }
	            }
	        }
	
	        return isFind;
	    }
	};



#### 面试题13：机器人的运动范围 ####

![](https://s3.uuu.ovh/imgs/2023/03/20/7da319746c7519dd.png#pic_left)

	class Solution {
	public:
	    vector<vector<bool>> isUsed;
	    int boxNum;
	    int maxRow;
	    int maxCol;
	    bool checkPosition(int threshold, int rows, int cols)
	    {
	        if (rows < 0 || cols < 0 || rows >= maxRow || cols >= maxCol || isUsed[rows][cols] == true) {
	            return false;
	        }
	
	        int sum = 0;
	        while (rows != 0) {
	            sum += rows % 10;
	            rows = rows / 10;
	        }
	
	        while (cols != 0) {
	            sum += cols % 10;
	            cols = cols / 10;
	        }
	
	        if (sum > threshold) {
	            return false;
	        }
	
	        return true;
	    }
	
	    void backTracking(int threshold, int rows, int cols)
	    {
	        if (!checkPosition(threshold, rows, cols)) {
	            return;
	        }
	
	        boxNum++;
	        // cout << "row: " << rows << " cols: " << cols << endl;
	        isUsed[rows][cols] = true;
	        // cout << "2 row: " << rows << " cols: " << cols << endl;
	
	        backTracking(threshold, rows - 1, cols);
	        backTracking(threshold, rows + 1, cols);
	        backTracking(threshold, rows, cols - 1);
	        backTracking(threshold, rows, cols + 1);
	    }
	
	    int movingCount(int threshold, int rows, int cols) {
	        maxRow = rows;
	        maxCol = cols;
	        // cout << rows << " " << cols << endl;
	        vector<bool> tmp(cols, false);
	        isUsed.resize(rows, tmp);
	        backTracking(threshold, 0, 0);
	        // cout << boxNum << endl;
	        return boxNum;
	    }
	};

#### 面试题14：剪绳子 ####

![](https://s3.uuu.ovh/imgs/2023/03/20/b20658b663ea6e7c.png#pic_left)

##### 动态规划解法： #####

	class Solution {
	public:
	    int cutRope(int number) {
	        if (number <= 1) {
	            return 0;
	        } else if (number == 2) {
	            return 1;
	        } else if (number == 3) {
	            return 2;
	        }
	
	        vector<int> dp(number + 1, 0);
	        dp[0] = 0;
	        dp[1] = 1;
	        dp[2] = 2;
	        dp[3] = 3;
	        for (int i = 4; i <= number; i++) {
	            int max = 0;
	            for (int j = 1; j < i; j++) {
	                int value = dp[i - j] * dp[j];
	                if (value > max) {
	                    max = value;
	                }
	            }
	
	            dp[i] = max;
	        }
	
	        return dp[number];
	    }
	};

##### 贪心解法： #####

	class Solution {
	public:
	    int cutRope(int number) {
	        if (number <= 1) {
	            return 0;
	        } else if (number == 2) {
	            return 1;
	        } else if (number == 3) {
	            return 2;
	        }
	
	        int result = 1;
	        while (number > 0) {
	            if (number > 5) {
	                result *= 3;
	                number -= 3;
	            } else if (number == 5) {
	                result *= 6;
	                number -= 5;
	            } else {
	                result *= number;
	                number -= number;
	            }
	        }
	
	        return result;
	    }
	};

#### 面试题15：二进制中1的个数 ####

![](https://s3.uuu.ovh/imgs/2023/03/20/9ee038ade8742ba8.png#pic_left)

	class Solution {
	public:
	    int  NumberOf1(int n) {
	        int oneNum = 0;
	        for (int i = 0; i < 32; i++) {
	            if ((n & (1 << i)) != 0) { // 注意里面的括号，很关键
	                oneNum++;
	            }
	        }
	
	        return oneNum;
	    }
	};


#### 面试题16：数值的整数次方 ####

![](https://s3.uuu.ovh/imgs/2023/03/20/2162ddae0aa01e26.png#pic_left)

	class Solution {
	public:
	    double Power(double base, int exponent) {
	        if (exponent == 0) {
	            return 1;
	        }
	
	        double result = 1.0;
	        bool isNegtive;
	        if (exponent > 0) {
	            isNegtive = false;
	        } else {
	            isNegtive = true;
	            exponent *= -1.0;
	        }
	
	        for (int i = 0; i < exponent; i++) {
	            result *= base;
	        }
	
	        if (isNegtive) {
	            result = 1.0 / result;
	        }
	
	        return result;
	    }
	};

### <a name="chapter3"></a>第三章 高质量的代码

#### 面试题17：打印从1到最大的n位数 ####

![](https://s3.uuu.ovh/imgs/2023/03/20/45c71667a29e9afc.png#pic_left)

	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     *
	     * @param n int整型 最大位数
	     * @return int整型vector
	     */
	    vector<int> printNumbers(int n) {
	        // write code here
	        vector<int> result;
	        int max = 1;
	        for (int i = 0; i < n; i++) {
	            max *= 10;
	        }
	
	        max -= 1;
	        for (int i = 1; i <= max; i++) {
	            result.emplace_back(i);
	        }
	
	        return result;
	    }
	};

#### 面试题18-1：删除链表的节点 ####

![](https://s3.uuu.ovh/imgs/2023/03/21/e20e7a96dbb84856.png#pic_left)

	/**
	 * struct ListNode {
	 *	int val;
	 *	struct ListNode *next;
	 *	ListNode(int x) : val(x), next(nullptr) {}
	 * };
	 */
	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param head ListNode类 
	     * @param val int整型 
	     * @return ListNode类
	     */
	    ListNode* deleteNode(ListNode* head, int val) {
	        // write code here
	        ListNode* preNode = head;
	        ListNode* node = head;
	        if (node->val == val) {
	            node = node->next;
	            preNode->next = nullptr;
	            return node; 
	        } else {
	            node = node->next;
	        }
	
	        while (node) {
	            if (node->val == val) {
	                preNode->next = node->next;
	                delete node;
	                break;
	            } else {
	                preNode = node;
	                node = node->next;
	            }
	        }
	
	        return head;
	    }
	};

#### 面试题18-2：删除链表的节点 ####

![](https://s3.uuu.ovh/imgs/2023/03/21/0a9346d35712372b.png#pic_left)

	/*
	struct ListNode {
	    int val;
	    struct ListNode *next;
	    ListNode(int x) :
	        val(x), next(NULL) {
	    }
	};
	*/
	class Solution {
	public:
	    ListNode* deleteDuplication(ListNode* pHead) {
	        bool isFind = false;
	        ListNode* node = pHead;
	        if (node == nullptr) {
	            return nullptr;
	        }
	
	        while (true) {
	            while (node->next && node->val == node->next->val) {
	                pHead = pHead->next;
	                node = pHead;
	                isFind = true;
	            }
	
	            if (isFind) {
	                pHead = pHead->next;
	                node = pHead;
	                isFind = false;
	            } else {
	                break;
	            }
	
	            if (node == nullptr) {
	                return nullptr;
	            }
	        }
	        
	        ListNode* pre = node;
	        while(node->next) {
	            while (node->next && node->val == node->next->val) {
	                pre->next = node->next;
	                node = node->next;
	                isFind = true;
	            }
	
	            if (isFind) {
	                pre->next = node->next;
	                node = node->next;
	                isFind = false;
	                if (node == nullptr) {
	                    break;
	                }
	            } else {
	                pre = node;
	                node = node->next;
	            }
	        }
	
	        return pHead;
	    }
	};

#### 面试题19：正则表达式匹配 ####



### <a name="chapter4"></a>第四章

    第四章内容

### <a name="chapter5"></a>第五章

    第五章内容

### <a name="chapter6"></a>第六章

    第六章内容

### <a name="chapter7"></a>第七章

    第七章内容

### <a name="chapter8"></a>第八章

    第八章内容

### 参考资源

    参考资源

转载请注明：[sizheluo的博客](https://sizheluo.github.io) » [文章标题](文章链接)