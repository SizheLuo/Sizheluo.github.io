---
layout: post
title: "JZ_Note"
date: 2023-03-19
description: "JZ算法题"
tag: 算法
---

### 前言

	`JZ算法题记录。`

### 目录

* [第一章](#chapter1)
* [第二章](#chapter2)
* [第三章](#chapter3)
* [第四章](#chapter4)
* [第五章](#chapter5)
* [第六章](#chapter6)
* [第七章](#chapter7)

### <a name="chapter1"></a>第一章

    第一章内容

### <a name="chapter2"></a>第二章 面试需要的基础知识

#### 前置知识 ####

一、关于sizeof
定义一个空类型，求sizeof得到的结果是1。空实例不包含任何信息 ，但必须在内存中占有一定的空间，否则无法使用这些实例。
再添加一个构造函数和析构函数，sizeof的结果还是1。调用构造函数只需要知道函数的地址即可，而这些函数的地址只与类型相关，而与类型的实例无关。
把析构函数标记为虚函数，sizeof的值为4或者8，为指针占用空间，会生成虚函数表，并在类的每一个实例中添加一个指向虚函数的指针。

#### 面试题1：赋值运算符函数 ####

#### 面试题2：实现Singleton模式，设计一个类，我们只能生成该类的一个实例 ####

#### 面试题3：数组中重复的数字 ####

在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。
也不知道每个数字重复几次。请找出数组中第一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，
那么对应的输出是第一个重复的数字2。
返回描述：
如果数组中有重复的数字，函数返回true，否则返回false。
如果数组中有重复的数字，把重复的数字放到参数duplication[0]中。（ps:duplication已经初始化，可以直接赋值使用。）

    class Solution {
    public:
	    bool duplicate(int numbers[], int length, int* duplication) {
	    	bool haveDuplication;
	    	int index = 0;
	    	vector<int> hashTable(length, -1);
	    	for (int i = 0; i < length; i++) {
		    	if (hashTable[numbers[i]] == -1) {
		    		hashTable[numbers[i]] = numbers[i];
		    	} else if (hashTable[numbers[i]] == numbers[i]) {
		    		duplication[index] = numbers[i];
				    index++;
				    break;
		    	}
	    	}
	    
		    if (index == 0) {
		    	haveDuplication = false;
		    } else {
		    	haveDuplication = true;
		    }
	    
	    	return haveDuplication;
	    }
    };

#### 面试题4： 二维数组中的查找 ####

在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
[
[1,2,8,9],
[2,4,9,12],
[4,7,10,13],
[6,8,11,15]
]
给定 target = 7，返回 true。
给定 target = 3，返回 false。

	class Solution {
	public:
	    int rightAndUp(int row, int column, vector<vector<int>> array)
	    {
	        return array[row][column];
	    }
	
	    bool Find(int target, vector<vector<int> > array) {
	        if (array.size() == 0 || array[0].size() == 0) {
	            return false;
	        }
	
	        int row = 0;
	        int column = array[0].size() - 1;
	        int value = array[row][column];
	        bool isFind = false;
	        while (true) {
	            cout << value << endl;
	            if (value > target) {
	                column--;
	            } else if (value < target) {
	                row++;
	            } else {
	                isFind = true;
	                break;
	            }
	
	            if (row == array.size() || column < 0) {
	                break;
	            } else {
	                value = rightAndUp(row, column, array);
	            }
	        }
	       
	        return isFind;
	    }
	};

#### 面试题5：替换空格 ####

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

	class Solution {
	public:
	    void replaceSpace(char *str,int length) {
	        int spaceNum = 0;
	        for (int i = 0; i < length; i++) {
	            if (str[i] == ' ') {
	                spaceNum++;
	            }
	        }
	
	        int paddingLen = 2 * spaceNum;
	        for (int i = (length + paddingLen), j = length; i >= 0 && j >= 0;) {
	            if (str[j] == ' ') {
	                str[i] = '0';
	                i--;
	                str[i] = '2';
	                i--;
	                str[i] = '%';
	                i--;
	                j--;
	            } else {
	                str[i] = str[j];
	                i--;
	                j--;
	            }
	        }
	
	        return;
	    }
	};

#### 面试题6：从尾到头打印链表 ####

输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。
如输入{1,2,3}的链表如下图:

![](https://s3.uuu.ovh/imgs/2023/03/20/17883538d3b8dd23.png#pic_left)

返回一个数组为[3,2,1]
0 <= 链表长度 <= 10000

	/**
	*  struct ListNode {
	*      int val;
	*      struct ListNode *next;
	*       ListNode(int x) :
	*           val(x), next(NULL) {
	*       }
	*  };
	*/

	class Solution {
	public:
	vector<int> result;
	void printListReverse(ListNode *node) {
	if (node != nullptr) {
	printListReverse(node->next);
	result.emplace_back(node->val);
	}
	
	return;
	}
	
	vector<int> printListFromTailToHead(ListNode* head) {
	printListReverse(head);
	return result;
	}
	};

#### 面试题7：重建二叉树 ####

![](https://s3.uuu.ovh/imgs/2023/03/22/698ec397835ee4d4.png)

	/**
	 * Definition for binary tree
	 * struct TreeNode {
	 *     int val;
	 *     TreeNode *left;
	 *     TreeNode *right;
	 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
	 * };
	 */
	class Solution {
	public:
	    TreeNode* reConstructInternal(vector<int> pre, vector<int> vin)
	    {
	        if (pre.size() == 0 || vin.size() == 0) {
	            return nullptr;
	        }
	
	        TreeNode *node = new TreeNode(pre[0]);
	        int indexInVin = 0;
	        for (int i = 0; i < vin.size(); i++) {
	            if (pre[0] == vin[i]) {
	                indexInVin = i;
	                break;
	            }
	        }
	
	        vector<int> leftPre(pre.begin() + 1, pre.begin() + 1 + indexInVin);
	        vector<int> rightPre(pre.begin() + 1 + indexInVin, pre.end());
	
	        vector<int> leftVin(vin.begin(), vin.begin() + indexInVin);
	        vector<int> rightVin(vin.begin() + indexInVin + 1, vin.end());
	
	        node->left = reConstructInternal(leftPre, leftVin);
	        node->right = reConstructInternal(rightPre, rightVin);
	
	        return node;
	    }
	
	    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
	        TreeNode *root = reConstructInternal(pre, vin);
	        return root;
	    }
	};

#### <font color="#0000dd">面试题8：重建二叉树描述</font><br /> ####

给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。下图为一棵有9个节点的二叉树。树中从父节点指向子节点的指针用实线表示，从子节点指向父节点的用虚线表示

![](https://s3.uuu.ovh/imgs/2023/03/20/6edf66e09fa2f118.png#pic_left)

	/*
	struct TreeLinkNode {
	    int val;
	    struct TreeLinkNode *left;
	    struct TreeLinkNode *right;
	    struct TreeLinkNode *next;
	    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) {
	       
	    }
	};
	*/
	class Solution {
	public:
	    TreeLinkNode* GetNext(TreeLinkNode* pNode) {
	        if (pNode == nullptr) {
	            return nullptr;
	        }
	
	        if (pNode->right != nullptr) { // 第一种情况，存在右子树
	            if (pNode->right->left == nullptr) {
	                return pNode->right;
	            } else {
	                TreeLinkNode *node = pNode->right;
	                while (node->left) {
	                    node = node->left;
	                }
	
	                return node;
	            }
	        } else {
	            if (pNode->next == nullptr) {
	                return nullptr;
	            } else if (pNode->next->left == pNode) {  // 第二种情况，不存在右子树且为父节点左子书
	                return pNode->next;
	            } else { // 第三种情况，不存在左子树且为父节点的右子树
	                TreeLinkNode *node = pNode->next;
	                TreeLinkNode *result = nullptr;
	                while (node->next) {
	                    if (node == node->next->left) {
	                        result = node->next;
	                        break;
	                    }
	
	                    node = node->next;
	                }
	
	                return result;
	            }
	        }
	    }
	};

#### 面试题9：用两个栈实现队列 ####

用两个栈来实现一个队列，使用n个元素来完成 n 次在队列尾部插入整数(push)和n次在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。

数据范围： n≤1000
要求：存储n个元素的空间复杂度为 O(n) ，插入与删除的时间复杂度都是 O(1)

	class Solution
	{
	public:
	    void push(int node) {
	        if (stack1.empty() && stack2.empty()) {
	            stack1.push(node);
	        } else if (!stack1.empty()) {
	            stack1.push(node);
	        } else {
	            stack1.push(node);
	        }
	    }
	
	    int pop() {
	        if (stack2.empty() && !stack1.empty()) {
	            int val;
	            while (!stack1.empty()) {
	                val = stack1.top();
	                stack1.pop();
	                stack2.push(val);
	            }
	
	            val = stack2.top();
	            stack2.pop();
	            return val;
	        } else {
	            int val = stack2.top();
	            stack2.pop();
	            return val;
	        }
	    }
	
	private:
	    stack<int> stack1;
	    stack<int> stack2;
	};

#### 面试题10：斐波那契数列 ####

	class Solution {
	public:
	    int Fibonacci(int n) {
	        if (n == 1 || n == 2) {
	            return 1;
	        } else {
	            return Fibonacci(n - 1) + Fibonacci(n - 2);
	        }
	    }
	};


#### <font color="#0000dd">面试题11：旋转数组的最小数字</font><br /> ####

有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。
数据范围：1≤n≤10000，数组中任意元素的值: 0≤val≤10000
要求：空间复杂度：O(1) ，时间复杂度：O(logn)

	class Solution {
	public:
	    int minNumberInRotateArray(vector<int> rotateArray) {
	        int left = 0;
	        int right = rotateArray.size() - 1;
	        while (left < right) {
	            int index = (left + right) / 2;
	            if (rotateArray[index] > rotateArray[right]) {
	                left = index + 1;
	            } else if (rotateArray[index] < rotateArray[right]) {
	                right = index;
	            } else {
	                right--;
	            }
	        }
	
	        return rotateArray[left];
	    }
	};

#### 面试题12：矩阵中的路径 ####

![](https://s3.uuu.ovh/imgs/2023/03/20/e297f05d6e4d8c9f.png#pic_left)

	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     *
	     * @param matrix char字符型vector<vector<>>
	     * @param word string字符串
	     * @return bool布尔型
	     */
	    vector<vector<bool>> isUsed;
	    string path;
	    bool isFind;
	    void backTracking(vector<vector<char>> &matrix, string word, int index, int row, int column)
	    {
	        cout << "row: " << row << " column: " << column << " index: " << index << " word: " << word << endl;
	        cout << "path: " << path << endl;
	        if (index >= word.size()) {
	            if (path == word) {
	                isFind = true;
	            }
	
	            return;
	        }
	
	        if (row > 0 && matrix[row - 1][column] == word[index] &&
	            isUsed[row - 1][column] == false) { // up
	            isUsed[row - 1][column] = true;
	            path += word[index];
	            backTracking(matrix, word, index + 1, row - 1, column);
	            path.pop_back();
	            isUsed[row - 1][column] = false;
	        }
	       
	        if (row < (matrix.size() - 1) && matrix[row + 1][column] == word[index] &&
	            isUsed[row + 1][column] == false) { //down
	            isUsed[row + 1][column] = true;
	            path += word[index];
	            backTracking(matrix, word, index + 1, row + 1, column);
	            path.pop_back();
	            isUsed[row + 1][column] = false;
	        }
	
	        if (column < (matrix[0].size() - 1) && matrix[row][column + 1] == word[index] &&
	            isUsed[row][column + 1] == false) { //right
	            isUsed[row][column + 1] = true;
	            path += word[index];
	            backTracking(matrix, word, index + 1, row, column + 1);
	            path.pop_back();
	            isUsed[row][column + 1] = false;
	        }
	
	        if (column > 0 && matrix[row][column - 1] == word[index] &&
	            isUsed[row][column - 1] == false) { //left
	            isUsed[row][column - 1] = true;
	            path += word[index];
	            backTracking(matrix, word, index + 1, row, column - 1);
	            path.pop_back();
	            isUsed[row][column - 1] = false;
	        }
	    }
	
	    bool hasPath(vector<vector<char> >& matrix, string word) {
	        // write code here
	        if (matrix.size() == 0 || matrix[0].size() == 0) {
	            return false;
	        }
	        isFind = false;
	        vector<bool> tmp(matrix[0].size(), false);
	        isUsed.resize(matrix.size(), tmp);
	        for (int i = 0; i < matrix.size(); i++) {
	            for (int j = 0; j < matrix[0].size(); j++) {
	                if (matrix[i][j] == word[0]) {
	                    // cout << "begin: " << i << "-"<< j << endl;
	                    isUsed[i][j] = true;
	                    path += word[0];
	                    backTracking(matrix, word, 1, i, j);
	                    path.pop_back();
	                    isUsed[i][j] = false;
	                }
	            }
	        }
	
	        return isFind;
	    }
	};



#### 面试题13：机器人的运动范围 ####

![](https://s3.uuu.ovh/imgs/2023/03/20/7da319746c7519dd.png#pic_left)

	class Solution {
	public:
	    vector<vector<bool>> isUsed;
	    int boxNum;
	    int maxRow;
	    int maxCol;
	    bool checkPosition(int threshold, int rows, int cols)
	    {
	        if (rows < 0 || cols < 0 || rows >= maxRow || cols >= maxCol || isUsed[rows][cols] == true) {
	            return false;
	        }
	
	        int sum = 0;
	        while (rows != 0) {
	            sum += rows % 10;
	            rows = rows / 10;
	        }
	
	        while (cols != 0) {
	            sum += cols % 10;
	            cols = cols / 10;
	        }
	
	        if (sum > threshold) {
	            return false;
	        }
	
	        return true;
	    }
	
	    void backTracking(int threshold, int rows, int cols)
	    {
	        if (!checkPosition(threshold, rows, cols)) {
	            return;
	        }
	
	        boxNum++;
	        // cout << "row: " << rows << " cols: " << cols << endl;
	        isUsed[rows][cols] = true;
	        // cout << "2 row: " << rows << " cols: " << cols << endl;
	
	        backTracking(threshold, rows - 1, cols);
	        backTracking(threshold, rows + 1, cols);
	        backTracking(threshold, rows, cols - 1);
	        backTracking(threshold, rows, cols + 1);
	    }
	
	    int movingCount(int threshold, int rows, int cols) {
	        maxRow = rows;
	        maxCol = cols;
	        // cout << rows << " " << cols << endl;
	        vector<bool> tmp(cols, false);
	        isUsed.resize(rows, tmp);
	        backTracking(threshold, 0, 0);
	        // cout << boxNum << endl;
	        return boxNum;
	    }
	};

#### 面试题14：剪绳子 ####

![](https://s3.uuu.ovh/imgs/2023/03/20/b20658b663ea6e7c.png#pic_left)

##### 动态规划解法： #####

	class Solution {
	public:
	    int cutRope(int number) {
	        if (number <= 1) {
	            return 0;
	        } else if (number == 2) {
	            return 1;
	        } else if (number == 3) {
	            return 2;
	        }
	
	        vector<int> dp(number + 1, 0);
	        dp[0] = 0;
	        dp[1] = 1;
	        dp[2] = 2;
	        dp[3] = 3;
	        for (int i = 4; i <= number; i++) {
	            int max = 0;
	            for (int j = 1; j < i; j++) {
	                int value = dp[i - j] * dp[j];
	                if (value > max) {
	                    max = value;
	                }
	            }
	
	            dp[i] = max;
	        }
	
	        return dp[number];
	    }
	};

##### 贪心解法： #####

	class Solution {
	public:
	    int cutRope(int number) {
	        if (number <= 1) {
	            return 0;
	        } else if (number == 2) {
	            return 1;
	        } else if (number == 3) {
	            return 2;
	        }
	
	        int result = 1;
	        while (number > 0) {
	            if (number > 5) {
	                result *= 3;
	                number -= 3;
	            } else if (number == 5) {
	                result *= 6;
	                number -= 5;
	            } else {
	                result *= number;
	                number -= number;
	            }
	        }
	
	        return result;
	    }
	};

#### 面试题15：二进制中1的个数 ####

![](https://s3.uuu.ovh/imgs/2023/03/20/9ee038ade8742ba8.png#pic_left)

	class Solution {
	public:
	    int  NumberOf1(int n) {
	        int oneNum = 0;
	        for (int i = 0; i < 32; i++) {
	            if ((n & (1 << i)) != 0) { // 注意里面的括号，很关键
	                oneNum++;
	            }
	        }
	
	        return oneNum;
	    }
	};


#### 面试题16：数值的整数次方 ####

![](https://s3.uuu.ovh/imgs/2023/03/20/2162ddae0aa01e26.png#pic_left)

	class Solution {
	public:
	    double Power(double base, int exponent) {
	        if (exponent == 0) {
	            return 1;
	        }
	
	        double result = 1.0;
	        bool isNegtive;
	        if (exponent > 0) {
	            isNegtive = false;
	        } else {
	            isNegtive = true;
	            exponent *= -1.0;
	        }
	
	        for (int i = 0; i < exponent; i++) {
	            result *= base;
	        }
	
	        if (isNegtive) {
	            result = 1.0 / result;
	        }
	
	        return result;
	    }
	};

### <a name="chapter3"></a>第三章 高质量的代码

#### 面试题17：打印从1到最大的n位数 ####

![](https://s3.uuu.ovh/imgs/2023/03/20/45c71667a29e9afc.png#pic_left)

	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     *
	     * @param n int整型 最大位数
	     * @return int整型vector
	     */
	    vector<int> printNumbers(int n) {
	        // write code here
	        vector<int> result;
	        int max = 1;
	        for (int i = 0; i < n; i++) {
	            max *= 10;
	        }
	
	        max -= 1;
	        for (int i = 1; i <= max; i++) {
	            result.emplace_back(i);
	        }
	
	        return result;
	    }
	};

#### 面试题18-1：删除链表的节点 ####

![](https://s3.uuu.ovh/imgs/2023/03/21/e20e7a96dbb84856.png#pic_left)

	/**
	 * struct ListNode {
	 *	int val;
	 *	struct ListNode *next;
	 *	ListNode(int x) : val(x), next(nullptr) {}
	 * };
	 */
	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param head ListNode类 
	     * @param val int整型 
	     * @return ListNode类
	     */
	    ListNode* deleteNode(ListNode* head, int val) {
	        // write code here
	        ListNode* preNode = head;
	        ListNode* node = head;
	        if (node->val == val) {
	            node = node->next;
	            preNode->next = nullptr;
	            return node; 
	        } else {
	            node = node->next;
	        }
	
	        while (node) {
	            if (node->val == val) {
	                preNode->next = node->next;
	                delete node;
	                break;
	            } else {
	                preNode = node;
	                node = node->next;
	            }
	        }
	
	        return head;
	    }
	};

#### 面试题18-2：删除链表的节点 ####

![](https://s3.uuu.ovh/imgs/2023/03/21/0a9346d35712372b.png#pic_left)

	/*
	struct ListNode {
	    int val;
	    struct ListNode *next;
	    ListNode(int x) :
	        val(x), next(NULL) {
	    }
	};
	*/
	class Solution {
	public:
	    ListNode* deleteDuplication(ListNode* pHead) {
	        bool isFind = false;
	        ListNode* node = pHead;
	        if (node == nullptr) {
	            return nullptr;
	        }
	
	        while (true) {
	            while (node->next && node->val == node->next->val) {
	                pHead = pHead->next;
	                node = pHead;
	                isFind = true;
	            }
	
	            if (isFind) {
	                pHead = pHead->next;
	                node = pHead;
	                isFind = false;
	            } else {
	                break;
	            }
	
	            if (node == nullptr) {
	                return nullptr;
	            }
	        }
	        
	        ListNode* pre = node;
	        while(node->next) {
	            while (node->next && node->val == node->next->val) {
	                pre->next = node->next;
	                node = node->next;
	                isFind = true;
	            }
	
	            if (isFind) {
	                pre->next = node->next;
	                node = node->next;
	                isFind = false;
	                if (node == nullptr) {
	                    break;
	                }
	            } else {
	                pre = node;
	                node = node->next;
	            }
	        }
	
	        return pHead;
	    }
	};

#### <font color="#0000dd">面试题19：正则表达式匹配</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/03/21/4a2671c469db895e.png)

	class Solution {
	    bool matchCore(const string& str,const string& pattern){
	        if(str.empty()&&pattern.empty())
	            return true;
	        if(!str.empty()&&pattern.empty())
	            return false;
	        if(pattern[1]=='*'){
	            if(pattern[0]==str[0]||(pattern[0]=='.'&&!str.empty()))
	                                //进入下一状态
	                return matchCore(str.substr(1),pattern.substr(2))
	                                //留在当前状态
	                                ||matchCore(str.substr(1), pattern)
	                                //忽略一个'*'
	                                ||matchCore(str, pattern.substr(2));
	            else
	                                //忽略一个'*'
	                return matchCore(str, pattern.substr(2));
	        }
	        if(str[0]==pattern[0]||(pattern[0]=='.'&&!str.empty()))
	            return matchCore(str.substr(1), pattern.substr(1));
	        
	        return false;
	    }
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param str string字符串 
	     * @param pattern string字符串 
	     * @return bool布尔型
	     */
	    bool match(string str, string pattern) {
	        // write code here
	        return matchCore(str,pattern);
	    }
	};

#### <font color="#0000dd">面试题20：表示数值的字符串</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/03/22/9bd8044402f878f0.png)

	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param str string字符串 
	     * @return bool布尔型
	     */
	    bool isUnsigned(string str, int &index)
	    {
	        if (index >= str.size()) {
	            return false;
	        }
	
	        int begin = index;
	        while (str[index] == ' ' || str[index] >= '0' && str[index] <= '9') {
	            if (str[index] == ' ') {
	                begin++;
	            }
	            cout << str[index] << endl;
	            index++;
	        }
	
	        return (index > begin);
	    }
	
	    bool isInterger(string str, int &index)
	    {
	        int begin = index;
	        while (str[index] == ' ' || str[index] == '+' || str[index] == '-') {
	            if (str[index] == ' ') {
	                begin++;
	            }
	
	            index++;
	        }
	
	        if ((index - begin) > 1) {
	            return false;
	        }
	
	        return (isUnsigned(str, index));
	    }
	
	    bool isNumeric(string str) {
	        // write code here
	        // A[.[B]][e|EC] || .[B][e|EC]
	        if (str.size() == 0) {
	            return false;
	        }
	
	        int index = 0;
	        bool result = isInterger(str, index);
	        if (index < str.size() && str[index] == '.') {
	            index++;
	            result = isUnsigned(str, index) || result;
	        }
	
	        if (index < str.size() && result && (str[index] == 'e' || str[index] == 'E')) {
	            index++;
	            if (index >= str.size()) {
	                result = false;
	            } else {
	                result = isInterger(str, index);
	            }
	        }
	
	        return result && (index == str.size());
	    }
	};

#### 面试题21：调整数组顺序使奇数位于偶数前面 ####

![](https://s3.uuu.ovh/imgs/2023/03/22/d5e16023d1d42fa4.png)

	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param array int整型vector 
	     * @return int整型vector
	     */
	    vector<int> reOrderArray(vector<int>& array) {
	        // write code here
	        vector<int> result;
	        for (int i = 0; i < array.size(); i++) {
	            int num = array[i] % 10;
	            if (num == 1 || num == 3 || num == 5 || num == 7 || num == 9) {
	                result.emplace_back(array[i]);
	            }
	        }
	
	        for (int i = 0; i < array.size(); i++) {
	            int num = array[i] % 10;
	            if (num == 0 || num == 2 || num == 4 || num == 6 || num == 8) {
	                result.emplace_back(array[i]);
	            }
	        }
	
	        return result;
	    }
	};

	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param array int整型vector 
	     * @return int整型vector
	     */
	    vector<int> reOrderArray(vector<int>& array) {
	        // write code here
	        int index = 0;
	        int i = 0;
	        while (i < array.size() - index) {
	            if ((array[i] & 0x1) == 0) {
	                int num = array[i];
	                for (int j = i; j < array.size() - 1; j++) {
	                    array[j] = array[j + 1];
	                }
	
	                array[array.size() - 1] = num;
	                index++;
	            } else {
	                i++;
	            }
	        }
	
	        return array;
	    }
	};

#### 面试题22：链表中倒数最后k个节点 ####

![](https://s3.uuu.ovh/imgs/2023/03/22/d64b5610beff634c.png)

	/**
	 * struct ListNode {
	 *	int val;
	 *	struct ListNode *next;
	 *	ListNode(int x) : val(x), next(nullptr) {}
	 * };
	 */
	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param pHead ListNode类 
	     * @param k int整型 
	     * @return ListNode类
	     */
	    ListNode* FindKthToTail(ListNode* pHead, int k) {
	        // write code here
	        if (pHead == nullptr || k == 0) {
	            return nullptr;
	        }
	
	        ListNode *left = pHead;
	        ListNode *right = pHead;
	        while (k > 1) {
	            right = right->next;
	            if (right == nullptr) {
	                return nullptr;
	            }
	
	            k--;
	        }
	
	        while (right->next) {
	            left = left->next;
	            right = right->next;
	        }
	
	        return left;
	    }
	};

#### <font color="#0000dd">面试题23：链表中环的入口节点</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/03/23/31e39167e94c4fe7.png)

	/*
	struct ListNode {
	    int val;
	    struct ListNode *next;
	    ListNode(int x) :
	        val(x), next(NULL) {
	    }
	};
	*/
	class Solution {
	public:
	    ListNode* EntryNodeOfLoop(ListNode* pHead) {
	        if (pHead == nullptr) {
	            return nullptr;
	        }
	
	        ListNode *fast = pHead;
	        ListNode *slow = pHead;
	        while (true) {
	            slow = slow->next;
	            if (!slow) {
	                return nullptr;
	            }
	
	            fast = fast->next->next;
	            if (!fast) {
	                return nullptr;
	            }
	
	            if (slow == fast) {
	                cout << slow->val << endl;
	                break;
	            }
	        }
	
	        ListNode *node = pHead;
	        while (true) {
	            if (slow == node) {
	                cout << node->val << endl;
	                break;
	            }
	
	            node = node->next;
	            slow = slow->next;
	        }
	
	        return node;
	    }
	};

#### 面试题24：反转链表 ####

![](https://s3.uuu.ovh/imgs/2023/03/22/576e0d5fb02feca0.png)

	/*
	struct ListNode {
		int val;
		struct ListNode *next;
		ListNode(int x) :
				val(x), next(NULL) {
		}
	};*/
	class Solution {
	public:
	    ListNode* ReverseList(ListNode* pHead) {
			if (pHead == nullptr || pHead->next == nullptr) {
				return pHead;
			}
	
			ListNode *next = pHead->next;
			ListNode *tempNode = next->next;
			pHead->next = nullptr;
			next->next = pHead;
			ListNode *pre = next;
			next = tempNode;
	
			while (next) {
				ListNode *temp = next->next;
				next->next = pre;
				pre = next;
				next = temp;
			}
	
			return pre;
	    }
	};

#### <font color="#0000dd">面试题25：合并两个排序的链表</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/03/24/ec5516071d31bf58.png)

	/*
	struct ListNode {
		int val;
		struct ListNode *next;
		ListNode(int x) :
				val(x), next(NULL) {
		}
	};*/
	class Solution {
	public:
	    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
	        if (!pHead1) {
				return pHead2;
			} else if (!pHead2) {
				return pHead1;
			}
	
			ListNode *node1 = pHead1;
			ListNode *node2 = pHead2;
			ListNode *head = nullptr;
			if (pHead1->val <= pHead2->val) {
				head = pHead1;
				node1 = pHead1->next;
			} else {
				head = pHead2;
				node2 = pHead2->next;
			}
	
			ListNode *node = head;
			while (node1 || node2) {
				if (!node1) {
					node->next = node2;
					break;
				} else if (!node2) {
					node->next = node1;
					break;
				}
	
				if (node1->val <= node2->val) {
					node->next = node1;
					node1 = node1->next;
				} else {
					node->next = node2;
					node2 = node2->next;
				}
	
				node = node->next;
			}
	
			return head;
	    }
	};


#### 面试题26：树的子结构 ####

![](https://s3.uuu.ovh/imgs/2023/03/24/96af247f4d314817.png)

	/*
	struct TreeNode {
		int val;
		struct TreeNode *left;
		struct TreeNode *right;
		TreeNode(int x) :
				val(x), left(NULL), right(NULL) {
		}
	};*/
	class Solution {
	public:
		bool result;
		bool isSameTree(TreeNode* node1, TreeNode* node2) {
			if (node2 != nullptr && node1 == nullptr) {
				return false;
			}
	
			if (node2 == nullptr) {
				return true;
			}
	
			bool isSameLeft = false;
			bool isSameRight = false;
			if (node1->val == node2->val) {
				isSameLeft = isSameTree(node1->left, node2->left);
				isSameRight = isSameTree(node1->right, node2->right);
			}
	
			return (isSameLeft && isSameRight);
		}
	
		void preOrder(TreeNode* node, TreeNode* pRoot2)
		{
			if (result || node == nullptr || pRoot2 == nullptr) {
				return;
			}
	
			if (node->val == pRoot2->val) {
				result = isSameTree(node, pRoot2);
			}
	
			preOrder(node->left, pRoot2);
			preOrder(node->right, pRoot2);
		}
	
	    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {
			result = false;
			preOrder(pRoot1, pRoot2);
			return result;
	    }
	};

### <a name="chapter4"></a>第四章 解决面试题的思路

#### 面试题27：二叉树的镜像 ####

![](https://s3.uuu.ovh/imgs/2023/03/24/9471a84604b0a69e.png)

	/**
	 * struct TreeNode {
	 *	int val;
	 *	struct TreeNode *left;
	 *	struct TreeNode *right;
	 *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
	 * };
	 */
	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param pRoot TreeNode类 
	     * @return TreeNode类
	     */
	    void MirrorInternal(TreeNode* node)
	    {
	        if (node == nullptr) {
	            return;
	        }
	
	        TreeNode* temp = node->left;
	        node->left = node->right;
	        node->right = temp;
	        MirrorInternal(node->left);
	        MirrorInternal(node->right);
	    }
	
	    TreeNode* Mirror(TreeNode* pRoot) {
	        // write code here
	        MirrorInternal(pRoot);
	        return pRoot;
	    }
	};

#### 面试题28：对称二叉树 ####

![](https://s3.uuu.ovh/imgs/2023/03/24/b9ebda534da4faa4.png)


	/*
	struct TreeNode {
	    int val;
	    struct TreeNode *left;
	    struct TreeNode *right;
	    TreeNode(int x) :
	            val(x), left(NULL), right(NULL) {
	    }
	};
	*/
	class Solution {
	public:
	    bool result;
	    void preOrder(TreeNode *node1, TreeNode *node2)
	    {
	        if (!result || node1 == nullptr && node2 == nullptr) {
	            return;
	        }
	
	        if (node1 == nullptr || node2 == nullptr) {
	            result = false;
	            return;
	        }
	
	        if (node1->val != node2->val) {
	            result = false;
	            return;
	        }
	        preOrder(node1->left, node2->right);
	        preOrder(node1->right, node2->left);
	    }
	
	    bool isSymmetrical(TreeNode* pRoot) {
	        result = true;
	        preOrder(pRoot, pRoot);
	        return result;
	    }
	
	};

#### 面试题29：顺时针打印矩阵 ####

![](https://s3.uuu.ovh/imgs/2023/03/26/5f698399fed650f2.png)

	class Solution {
	public:
	    vector<int> result;
	    void printOneCircle(vector<vector<int>> matrix, int times)
	    {
	        // 从左到右（外扩）
	        for (int i = times; i < matrix[0].size() - times; i++) {
	            result.emplace_back(matrix[times][i]);
	        }
	
	        // 从上到下（内缩）
	        for (int i = times + 1; i < matrix.size() - times - 1; i++) {
	            result.emplace_back(matrix[i][matrix[0].size() - 1 - times]);
	        }
	
	        // 从右到左（外扩）
	        for (int i = matrix[0].size() - 1 - times; i >= times; i--) {
	            if (matrix.size() - 1 - times == times) { // 同一行去重
	                break;
	            }
	            result.emplace_back(matrix[matrix.size() - 1 - times][i]);
	        }
	        
	        // 从下到上（内缩）
	        for (int i = matrix.size() - 2 - times; i > times; i--) {
	            if (matrix[0].size() - 1 - times == times) { // 同一列去重
	                break;
	            }
	            result.emplace_back(matrix[i][times]);
	        }
	    }
	
	    vector<int> printMatrix(vector<vector<int>> matrix) {
	        int times = 0;
	        while (result.size() != matrix.size() * matrix[0].size()) {
	            printOneCircle(matrix, times);
	            times++;
	        }
	
	        return result;
	    }
	};

#### <font color="#0000dd">面试题30：包含min函数的栈</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/03/26/9398107bb1403a0e.png)

	class Solution {
	public:
	    stack<int> minStack;
	    stack<int> valStack;
	
	    void push(int value) {
	        valStack.push(value);
	        if (minStack.empty()) {
	            minStack.push(value);
	        } else {
	            int minVal = minStack.top();
	            if (minVal > value) {
	                minVal = value;
	            }  
	
	            minStack.push(minVal);
	        }
	    }
	
	    void pop() {
	        minStack.pop();
	        valStack.pop();
	    }
	
	    int top() {
	        return valStack.top();    
	    }
	
	    int min() {
	        return minStack.top();
	    }
	};

#### 面试题31：栈的压入、弹出序列 ####

![](https://s3.uuu.ovh/imgs/2023/03/26/9612b1894f64b870.png)

	class Solution {
	public:
	    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
	        stack<int> stk;
	        int pushIndex = 0;
	        int popIndex = 0;
	        while (pushIndex <= pushV.size()) {
	            if (stk.empty()) {
	                if (pushIndex >= pushV.size()) {
	                    break;
	                }
	                stk.push(pushV[pushIndex]);
	                pushIndex++;
	            }
	
	            if (stk.top() == popV[popIndex]) {
	                stk.pop();
	                popIndex++;
	            } else {
	                if (pushIndex >= pushV.size()) {
	                    break;
	                }
	                stk.push(pushV[pushIndex]);
	                pushIndex++;
	            }
	        }
	
	        cout << popIndex << endl;
	        return (popV.size() == popIndex);
	    }
	};

#### 面试题32-1：从上往下打印二叉树 ####

![](https://s3.uuu.ovh/imgs/2023/03/26/a2224d925a397ead.png)

	/*
	struct TreeNode {
	    int val;
	    struct TreeNode *left;
	    struct TreeNode *right;
	    TreeNode(int x) :
	            val(x), left(NULL), right(NULL) {
	    }
	};*/
	class Solution {
	public:
	    vector<int> PrintFromTopToBottom(TreeNode* root) {
	        vector<int> result;
	        queue<TreeNode*> nodeQue;
	        if (root != nullptr) {
	            nodeQue.push(root);
	        }

	        while (!nodeQue.empty()) {
	            int queueSize = nodeQue.size();
	            for (int i = 0; i < queueSize; i++) {
	                TreeNode *tempNode = nodeQue.front();
	                nodeQue.pop();
	                result.emplace_back(tempNode->val);
	                if (tempNode->left) {
	                    nodeQue.push(tempNode->left);
	                }
	
	                if (tempNode->right) {
	                    nodeQue.push(tempNode->right);
	                }
	            }
	        }

	        return result;
	    }
	};

#### 面试题32-2：按之字形打印二叉树 ####

![](https://s3.uuu.ovh/imgs/2023/03/27/1f3e81875eb0bfbb.png)

	/*
	struct TreeNode {
	    int val;
	    struct TreeNode *left;
	    struct TreeNode *right;
	    TreeNode(int x) :
	            val(x), left(NULL), right(NULL) {
	    }
	};
	*/
	class Solution {
	public:
	    vector<vector<int>> result;
	    vector<vector<int> > Print(TreeNode* pRoot) {
	        queue<TreeNode*> nodeQue;
	        if (pRoot != nullptr) {
	            nodeQue.push(pRoot);
	        }
	
	        int flag = 1;
	        while (!nodeQue.empty()) {
	            int queueSize = nodeQue.size();
	            vector<int> path;
	            for (int i = 0; i < queueSize; i++) {
	                TreeNode *node = nodeQue.front();
	                nodeQue.pop();
	                path.emplace_back(node->val);
	                if (node->left) {
	                    nodeQue.push(node->left);
	                }
	
	                if (node->right) {
	                    nodeQue.push(node->right);
	                }
	            }
	
	            if (flag > 0) {
	                result.emplace_back(path);
	            } else {
	                reverse(path.begin(), path.end());
	                result.emplace_back(path);
	            }
	
	            flag *= -1;
	        }
	
	        return result;
	    }
	    
	};

#### 面试题33：二叉搜索树的后序遍历序列 ####

![](https://s3.uuu.ovh/imgs/2023/03/28/8879135b3d63fbfe.png)

	class Solution {
	public:
	    bool isBST(vector<int> nums)
	    {
	        if (nums.size() == 0) {
	            return true;
	        }
	
	        int node = nums[nums.size() - 1];
	        int index = -1;
	        for (int i = 0; i < nums.size(); i++) {
	            if (nums[i] > node) {
	                index = i;
	                break;
	            }
	        }
	
	        for (int i = index; (i >= 0 && i < nums.size()); i++) {
	            if (nums[i] < node) {
	                return false;
	            }
	        }
	
	        if (index < 0) {
	            index = 0;
	        }
	
	        vector<int> left(nums.begin(), nums.begin() + index);
	        vector<int> right(nums.begin() + index, nums.end() - 1);
	        bool leftIsBST = isBST(left);
	        bool rightIsBST = isBST(right);
	        return (leftIsBST && rightIsBST);
	    }
	
	    bool VerifySquenceOfBST(vector<int> sequence) {
	        if (sequence.size() == 0) {
	            return false;
	        }
	
	        bool result = isBST(sequence);
	        return result;
	    }
	};

#### 面试题34：二叉树中和为某一值的路径 ####

![](https://s3.uuu.ovh/imgs/2023/03/28/44b035aa964787c6.png)

	/*
	struct TreeNode {
		int val;
		struct TreeNode *left;
		struct TreeNode *right;
		TreeNode(int x) :
				val(x), left(NULL), right(NULL) {
		}
	};*/
	#include <numeric>
	class Solution {
	public:
		vector<vector<int>> result;
		vector<int> path;
		void preOrder(TreeNode *node, int expectNumber)
		{
			if (node == nullptr) {
				return;
			}
		
			path.emplace_back(node->val);
			if (node->left) {
				preOrder(node->left, expectNumber);
			}
		
			if (node->right) {
				preOrder(node->right, expectNumber);
			}
		
			if (!node->left && !node->right) {
				if (!path.empty()) {;
					if (accumulate(path.begin(), path.end(), 0) == expectNumber) {
						result.emplace_back(path);
					}
				}
			}
		
			path.pop_back();
		}
		vector<vector<int>> FindPath(TreeNode* root,int expectNumber) {
		    preOrder(root, expectNumber);
			return result;
		}
	};

#### <font color="#0000dd">面试题35：复杂链表的复制</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/03/29/62463c6ca0a47814.png)

	/*
	struct RandomListNode {
	    int label;
	    struct RandomListNode *next, *random;
	    RandomListNode(int x) :
	            label(x), next(NULL), random(NULL) {
	    }
	};
	*/
	class Solution {
	public:
	    RandomListNode* Clone(RandomListNode* pHead) {
	        unordered_map<RandomListNode*, RandomListNode*> listHash;
	        RandomListNode *node = pHead;
	        RandomListNode *newHead = nullptr;
	        RandomListNode *preNewNode = nullptr;
	        while (node) {
	            RandomListNode *newNode = new RandomListNode(node->label);
	            listHash[node] = newNode;
	            node = node->next;
	
	            if (!newHead) {
	                newHead = newNode;
	                preNewNode = newNode;
	            } else {
	                preNewNode->next = newNode;
	                preNewNode = newNode;
	            }
	        }
	
	        node = pHead;
	        RandomListNode *newNode = newHead;
	        while (node) {
	            RandomListNode *randNode = node->random;
	            if (randNode) {
	                randNode = listHash[randNode];
	                newNode->random = randNode;
	            }
	
	            node = node->next;
	            newNode = newNode->next;
	        }
	
	        return newHead;
	    }
	};

#### 面试题36：二叉搜索树与双向链表 ####

![](https://s3.uuu.ovh/imgs/2023/03/30/da03d3896bdb0c54.png)

	/*
	struct TreeNode {
	    int val;
	    struct TreeNode *left;
	    struct TreeNode *right;
	    TreeNode(int x) :
	            val(x), left(NULL), right(NULL) {
	    }
	};*/
	class Solution {
	public:
	    vector<TreeNode*> nums;
	    TreeNode* preNode;
	    TreeNode* head;
	
	    void inOrder(TreeNode* node)
	    {
	        if (node == nullptr) {
	            return;
	        }
	
	        inOrder(node->left);
	        if (head == nullptr) {
	            head = node;
	        }
	
	        if (preNode) {
	            preNode->right = node;
	            node->left = preNode;
	        }
	
	        nums.emplace_back(node);
	        preNode = node;
	        inOrder(node->right);
	    }
	
	    TreeNode* Convert(TreeNode* pRootOfTree) {
	        head = nullptr;
	        preNode = nullptr;
	        inOrder(pRootOfTree);
	        return head;
	    }
	};

#### <font color="#0000dd">面试题37：序列化二叉树</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/03/31/c1247d9fb7723df0.png)

	/*
	struct TreeNode {
	    int val;
	    struct TreeNode *left;
	    struct TreeNode *right;
	    TreeNode(int x) :
	            val(x), left(NULL), right(NULL) {
	    }
	};
	*/
	class Solution {
	public:
	    
	    char* Serialize(TreeNode *root) {
	        string result;
	        queue<TreeNode*> nodeQue;
	        if (root) {
	            nodeQue.push(root);
	        }
	
	        while (!nodeQue.empty()) {
	            int queueSize = nodeQue.size();
	            for (int i = 0; i < queueSize; i++) {
	                TreeNode *node = nodeQue.front();
	                nodeQue.pop();
	                if (node == nullptr) {
	                    result += '#';
	                    continue;
	                } else {
	                    result += to_string(node->val) + ',';
	                }
	
	                nodeQue.push(node->left);
	                nodeQue.push(node->right);
	            }
	        }
	
	        if (result.size() == 0) {
	            return nullptr;
	        }
	
	        char *serializeArray = new char[result.size() + 1];
	        strcpy(serializeArray, result.c_str());
	        return serializeArray;
	    }
	
	    TreeNode* Deserialize(char *str) {
	        if (str == nullptr) {
	            return nullptr;
	        }
	
	        string data = string(str);
	        vector<string> nums;
	        for (int i = 0; i < data.size(); i++) {
	            if (data[i] == '#') {
	                nums.emplace_back("#");
	            } else {
	                int endIndex = i;
	                while (data[endIndex] != ',') {
	                    endIndex++;
	                }
	
	                nums.emplace_back(data.substr(i, endIndex - i));
	                i = endIndex;
	            }
	        }
	
	        queue<TreeNode*> nodeQue;
	        TreeNode *node = new TreeNode(stoi(nums[0]));
	        TreeNode *head = node;
	        nodeQue.push(node);
	        int numIndex = 1;
	        while (!nodeQue.empty()) {
	            int queueSize = nodeQue.size();
	            for (int i = 0; i < queueSize; i++) {
	                TreeNode *tempNode = nodeQue.front();
	                nodeQue.pop();
	                for (int j = 0; j < 2; j++) {
	                    if (nums[numIndex] == "#") {
	                        numIndex++;
	                    } else {
	                        node = new TreeNode(stoi(nums[numIndex]));
	                        nodeQue.push(node);
	                        if (j == 0) {
	                            tempNode->left = node;
	                        } else {
	                            tempNode->right = node;
	                        }
	
	                        numIndex++;
	                    }
	                }
	            }
	        }
	
	        return head;
	    }
	};


#### 面试题38：字符串的排列 ####

![](https://s3.uuu.ovh/imgs/2023/03/31/1571cba3cf00f225.png)

	class Solution {
	public:
	    string path;
	    vector<string> result;
	    vector<int> isUsed;
	
	    void backTracking(string str)
	    {
	        if (path.size() == str.size()) {
	            result.emplace_back(path);
	            return;
	        }
	
	        for (int i = 0; i < str.size(); i++) {
	            if (i > 0 && str[i] == str[i - 1] && isUsed[i - 1] == false) { // 同一树层去重
	                continue;
	            }
	
	            if (isUsed[i] == false) { // 同一树枝去重
	                isUsed[i] = true;
	                path += str[i];
	                backTracking(str);
	                path.pop_back();
	                isUsed[i] = false;
	            }
	        }
	    }
	
	    vector<string> Permutation(string str) {
	        isUsed.resize(str.size(), false);
	        sort(str.begin(), str.end());
	        backTracking(str);
	        return result;
	    }
	};

### <a name="chapter5"></a>第五章

#### 面试题39：数组中出现次数超过一半的数字 ####

![](https://s3.uuu.ovh/imgs/2023/04/01/58767e0a36e5e150.png)

	class Solution {
	public:
	    int MoreThanHalfNum_Solution(vector<int> numbers) {
	        int times = 1;
	        int result = numbers[0];
	        for (int i = 1; i < numbers.size(); i++) {
	            if (result == numbers[i]) {
	                times++;
	            } else {
	                times--;
	            }
	
	            if (times == 0) {
	                result = numbers[i];
	                times = 1;
	            }
	        }
	
	        return result;
	    }
	};

#### 面试题40：最小的k个数 ####

![](https://s3.uuu.ovh/imgs/2023/04/01/e604c97c50ed5dc5.png)

	class Solution {
	public:
	    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
	        vector<int> result;
	        priority_queue<int, vector<int>, less<int>> pq;
	        for (int i = 0; i < input.size(); i++) {
	            if (pq.size() <= k - 1) {
	                pq.push(input[i]);
	            } else {
	                if (pq.top() > input[i]) {
	                    pq.pop();
	                    pq.push(input[i]);
	                }
	            }
	        }
	
	        for (int i = 0; i < k; i++) {
	            result.emplace_back(pq.top());
	            pq.pop();
	        }
	
	        sort(result.begin(), result.end());
	        return result;
	    }
	};

#### 面试题41：数据流中的中位数 ####

![](https://s3.uuu.ovh/imgs/2023/04/01/1de8de50e64bfeeb.png)

	class Solution {
	public:
	    vector<int> nums;
	    void Insert(int num) {
	        nums.emplace_back(num);
	    }
	
	    double GetMedian() { 
	        double result;
	        sort(nums.begin(), nums.end());
	        if ((nums.size() & 0x1) == 0) {
	            result = double(nums[nums.size() / 2.0 - 1] + nums[nums.size() / 2]) / 2;
	        } else {
	            result = nums[nums.size() / 2];
	        }
	
	        return result;
	    }
	};

#### 面试题42：连续子数组的最大和 ####

![](https://s3.uuu.ovh/imgs/2023/04/02/70a6630b7020009c.png)
	
	// 1.贪心
	class Solution {
	public:
	    int FindGreatestSumOfSubArray(vector<int> array) {
	        int left = 0;
	        int right = 0;
	        int result = array[0];
	        int sum = array[0];
	        while (left <= right && right < array.size()) {
	            if (sum > result) {
	                result = sum;
	            }
	
	            if (sum < 0) {
	                left++;
	                if (left > right) {
	                    right = left;
	                    sum = array[left];
	                } else {
	                    sum -= array[left - 1];
	                }
	            } else {
	                right++;
	                sum += array[right];
	            }
	        }
	
	        return result;
	    }
	};

	// 2.动态规划
	class Solution {
	public:
	    int FindGreatestSumOfSubArray(vector<int> array) {
	        vector<int> dp(array.size() + 1, -INT_MAX);
	        dp[0] = array[0];
	        int max = array[0];
	        for (int i = 1; i < array.size(); i++) {
	            if (dp[i - 1] < 0) {
	                dp[i] = array[i];
	            } else {
	                dp[i] = dp[i - 1] + array[i];
	            }
	
	            if (dp[i] > max) {
	                max = dp[i];
	            }
	        }
	
	        return max;
	    }
	};

#### <font color="#0000dd">面试题43：从1到n整数中1出现的次数</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/04/03/459866c93c009b4f.png)

![解析](https://uploadfiles.nowcoder.com/images/20211002/397721558_1633165446985/F447F7CD93DA16D30053692A73B55C72)

	class Solution {
	public:
	    int NumberOf1Between1AndN_Solution(int n) {
	        int result = 0;
	        long long int iter = 1;
	        int num = n;
	        while (num > 0) {
	            result += (num / 10) * iter + min(iter, max((long long)0, n % (iter * 10) - iter + 1));
	            iter *= 10;
	            num /= 10;
	        }
	
	        return result;
	    }
	};

#### 面试题44：数字序列中某一位的数字 ####

![](https://s3.uuu.ovh/imgs/2023/04/04/0fe0eab7523e7002.png)

	#include <string>
	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param n int整型 
	     * @return int整型
	     */
	    int findNthDigit(int n) {
	        // write code here 10 90 900 9000
	        if (n <= 9) {
	            return n;
	        }
	
	        long long int index = n - 10;
	        long long int gap = 90;
	        int times = 2;
	        while (true) {
	            if (index - gap * times < 0) {
	                break;
	            } else {
	                index -= gap * times;
	                times++;
	                gap *= 10;
	            }
	        }
	
	        long long int num = index / (times) + pow(10, times - 1);
	        long long int offset = index % (times);
	        long long int result = (long long int)(to_string(num)[offset] - '0');
	        return result;
	    }
	};

#### 面试题45：把数组排成最小的数 ####

![](https://s3.uuu.ovh/imgs/2023/04/04/cf68f2b8e463d431.png)

	class Solution {
	public:
	    static bool cmp(string a, string b)
	    {
	        string str1 = a + b;
	        string str2 = b + a;
	        return str1 < str2;
	    }
	
	    string PrintMinNumber(vector<int> numbers) {
	        string result;
	        vector<string> str;
	        for (int i = 0; i < numbers.size(); i++) {
	            str.emplace_back(to_string(numbers[i]));
	        }
	
	        sort(str.begin(), str.end(), cmp);
	        for (int i = 0; i < str.size(); i++) {
	            result += str[i];
	        }
	
	        return result;
	    }
	};

#### <font color="#0000dd">面试题46：把数字翻译成字符串</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/04/07/e18b6f3e9505f27c.png)

	// 回溯暴搜（超时）
	class Solution {
	public:
	    /**
	     * 解码
	     * @param nums string字符串 数字串
	     * @return int整型
	     */
	    int result;
	    string path;
	    bool isValid(string nums, int start, int end)
	    {
	        string str = nums.substr(start, end);
	        int num = atoi(str.c_str());
	        if (num < 1 || num > 26) {
	            return false;
	        }
	
	        return true;
	    }
	
	    void backTracking(string nums, int startIndex)
	    {
	        if (startIndex >= nums.size()) {
	            result++;
	            return;
	        }
	
	        for (int i = startIndex; i < nums.size(); i++) {
	            if (!isValid(nums, startIndex, i - startIndex + 1)) {
	                return;
	            }
	
	            backTracking(nums, i + 1);
	        }
	    }
	
	    int solve(string nums) {
	        // write code here
	        result = 0;
	        path = "";
	        backTracking(nums, 0);
	        return result;
	    }
	};

	// 动态规划：
	class Solution {
	public:
	    bool isTwoTypes(string str)
	    {
	        int num = atoi(str.c_str());
	        if ((num >= 11 && num <= 19) || (num >= 21 && num <=26)) {
	            return true;
	        }
	
	        return false;
	    }
	
	    int solve(string nums) {
	        if(nums == "0")  
	            return 0;
	
	        //当0的前面不是1或2时，无法译码，0种
	        for(int i = 1; i < nums.length(); i++) {  
	            if(nums[i] == '0')
	                if(nums[i - 1] != '1' && nums[i - 1] != '2')
	                    return 0;
	        }
	
	        vector<int> dp(nums.length() + 1, 0);
	        dp[0] = 1;
	        dp[1] = 1; 
	        for(int i = 2; i <= nums.length(); i++){
	            //在11-19，21-26之间的情况
	            if(isTwoTypes(nums.substr(i - 2, 2))) {
	               dp[i] = dp[i - 1] + dp[i - 2];
	            } else {
	                dp[i] = dp[i - 1];
	            }
	        }
	
	        return dp[nums.length()];
	    }
	};

#### 面试题47：礼物的最大价值 ####

![](https://s3.uuu.ovh/imgs/2023/04/07/4d3e54578659ca48.png)

	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param grid int整型vector<vector<>> 
	     * @return int整型
	     */
	    int maxValue(vector<vector<int> >& grid) {
	        // write code here
	        vector<vector<int>> dp(grid.size(), vector<int>(grid[0].size(), 0));
	        dp[0][0] = grid[0][0];
	        for (int i = 1; i < grid.size(); i++) {
	            dp[i][0] = dp[i - 1][0] + grid[i][0];
	        }
	
	        for (int i = 0; i < grid[0].size(); i++) {
	            dp[0][i] = dp[0][i - 1] + grid[0][i]; 
	        }
	
	        for (int i = 1; i < grid.size(); i++) {
	            for (int j = 1; j < grid[0].size(); j++) {
	                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
	            }
	        }
	
	        return dp[grid.size() - 1][grid[0].size() - 1];
	    }
	};

#### 面试题48：最长不含重复字符的子字符串 ####

![](https://s3.uuu.ovh/imgs/2023/04/08/6993692020b8778a.png)

	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param s string字符串 
	     * @return int整型
	     */
	    int lengthOfLongestSubstring(string s) {
	        // write code here
	        unordered_map<char, int> strMap;
	        int left = 0;
	        int right = 0;
	        int len = 1;
	        while (left < s.size() && right < s.size()) {
	            if (strMap.find(s[right]) == strMap.end()) {
	                strMap[s[right]] = right;
	                right++;
	            } else {
	                int endIndex = strMap[s[right]];
	                while (left <= endIndex) {
	                    strMap.erase(s[left]);
	                    left++;
	                }
	            }
	
	            if (right - left > len) {
	                len = right - left;
	            }
	        }
	
	        return len;
	    }
	};

#### <font color="#0000dd">面试题49：丑数</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/04/11/f6ca0554f4139e66.png)

	#include <queue>
	class Solution {
	public:
	    int GetUglyNumber_Solution(int index) {
	        if (index == 0) {
	            return 0;
	        }
	
	        priority_queue<long, vector<long>, greater<long>> pq;
	        unordered_map<long, int> num2Index;
	        vector<int> factor = {2, 3, 5};
	        pq.push(1);
	        int curIndex = 0;
	        int num = 1;
	        while (curIndex < index) {
	            num = pq.top();
	            pq.pop();
	            for (int i = 0; i <= 2; i++) {
	                if (num2Index[num * factor[i]] == 0) {
	                    num2Index[num * factor[i]] = 1;
	                    pq.push(num * factor[i]);
	                }
	            }
	
	            curIndex++;
	        }
	
	        return num;
	    }
	};

#### 面试题50：最长不含重复字符的子字符串 ####

![](https://s3.uuu.ovh/imgs/2023/04/19/0adf0158f4a792a0.png)

	class Solution {
	public:
	    int FirstNotRepeatingChar(string str) {
	        int result = -1;
	        unordered_map<char, int> hashTable1;
	        vector<int> hashTable(100, -1);
	        for (int i = 0; i < str.size(); i++) {
	            if (hashTable[str[i] - 'A'] >= 0 || hashTable[str[i] - 'A'] == -2) {
	                hashTable[str[i] - 'A'] = -2;
	                continue;
	            }
	
	            hashTable[str[i] - 'A'] = i;
	        }
	
	        for (int i = 0; i < 100; i++) {
	            if (hashTable[i] >= 0) {
	                if (result < 0 || result > hashTable[i]) {
	                    result = hashTable[i];
	                }
	            }
	        }
	
	        return result;
	    }
	};

#### 面试题51：数组中的逆序对 ####

![](https://s3.uuu.ovh/imgs/2023/04/19/d96f16115aaf5284.png)

	class Solution {
	public:
	    int InversePairs(vector<int> data) {
	        long long int result = 0;
	        for (long long int i = 0; i < data.size(); i++) {
	            for (long long int j = i + 1; j < data.size(); j++) {
	                if (data[i] > data[j]) {
	                    result++;
	                }
	            }
	        }
	
	        return (result % 1000000007);
	    }
	};

**// TODO: 归并排序法**

#### 面试题52：两个链表的第一个公共节点 ####

![](https://s3.uuu.ovh/imgs/2023/04/19/c973accf9a20eac7.png)

	/*
	struct ListNode {
		int val;
		struct ListNode *next;
		ListNode(int x) :
				val(x), next(NULL) {
		}
	};*/
	class Solution {
	public:
	    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
			int head1Len = 0;
			int head2Len = 0;
			ListNode *node1 = pHead1;
			ListNode *node2 = pHead2;
	        while (node1 != nullptr) {
				head1Len++;
				node1 = node1->next;
			}
	
			while (node2) {
				head2Len++;
				node2 = node2->next;
			}
	
			node1 = pHead1;
			node2 = pHead2;
			int gap = head1Len - head2Len;
			if (gap > 0) {
				while (gap > 0) {
					node1 = node1->next;
					gap--;
				}
			} else {
				gap *= -1;
				while (gap > 0) {
					node2 = node2->next;
					gap--;
				}
			}
	
			while (node1 != nullptr || node2 != nullptr) {
				if (node1 == node2) {
					return node1;
				}
	
				node1 = node1->next;
				node2 = node2->next;
			}
	
			return nullptr;
	    }
	};

### <a name="chapter6"></a>第六章

#### 面试题53：数字在升序数组中出现的次数 ####

![](https://s3.uuu.ovh/imgs/2023/04/20/79ed80def2a517cb.png)

	class Solution {
	public:
	    int GetNumberOfK(vector<int> data, int k) {
	        if (data.size() == 0) {
	            return 0;
	        }
	
	        int result = 0;
	        int left = 0;
	        int right = data.size() - 1;
	        int index = 0;
	        while (left < right) {
	            index = (left + right) / 2;
	            if (data[index] < k) {
	                left = index + 1;
	            } else if (data[index] > k) {
	                right = index - 1;
	            } else {
	                break;
	            }
	        }
	
	        left = index;
	        right = index + 1;
	        while (left >= 0 && data[left] == k) {
	            result++;
	            left--;
	        }
	
	        while (right < data.size() && data[right] == k) {
	            result++;
	            right++;
	        }
	
	        return result;
	    }
	};

#### 面试题54：二叉搜索树的第k个节点 ####

![](https://s3.uuu.ovh/imgs/2023/04/21/1ed42463ef8e787b.png)

	/**
	 * struct TreeNode {
	 *	int val;
	 *	struct TreeNode *left;
	 *	struct TreeNode *right;
	 *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
	 * };
	 */
	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param proot TreeNode类 
	     * @param k int整型 
	     * @return int整型
	     */
	    vector<int> result;
	
	    void inOrder(TreeNode *node)
	    {
	        if (node == nullptr) {
	            return;
	        }
	
	        inOrder(node->left);
	        result.emplace_back(node->val);
	        inOrder(node->right);
	        return;
	    }
	
	    int KthNode(TreeNode* proot, int k) {
	        // write code here
	        result.clear();
	        inOrder(proot);
	        if (k <= 0 || k > result.size()) {
	            return -1;
	        }
	
	        return result[k - 1];
	    }
	};

#### 面试题55：二叉树的深度 ####

![](https://s3.uuu.ovh/imgs/2023/04/21/e0565ed7c0ad6e89.png)

	/*
	struct TreeNode {
		int val;
		struct TreeNode *left;
		struct TreeNode *right;
		TreeNode(int x) :
				val(x), left(NULL), right(NULL) {
		}
	};*/

	// 1. BFS
	class Solution {
	public:
		vector<vector<int>> result;
	    int TreeDepth(TreeNode* pRoot) {
			queue<TreeNode*> nodeQue;
			if (pRoot) {
				nodeQue.push(pRoot);
			}
	
			while (!nodeQue.empty()) {
				int queueSize = nodeQue.size();
				vector<int> path;
				for (int i = 0; i < queueSize; i++) {
					TreeNode* node = nodeQue.front();
					path.emplace_back(node->val);
					nodeQue.pop();
					if (node->left) {
						nodeQue.push(node->left);
					}
	
					if (node->right) {
						nodeQue.push(node->right);
					}
				}
	
				result.emplace_back(path);
			}
	
			return result.size();
	    }
	};

	// 2. DFS
	class Solution {
	public:
		int result;
		void preOrder(TreeNode* node, int depth)
		{
			if (node == nullptr) {
				return;
			}
	
			if (depth > result) {
				result = depth;
			}
	
			depth++;
			preOrder(node->left, depth);
			preOrder(node->right, depth);
			depth--;
			return;
		}
	
	    int TreeDepth(TreeNode* pRoot) {
			result = 0;
			preOrder(pRoot, 1);
			return result;
	    }
	};

#### <font color="#0000dd">面试题56：数组中只出现一次的两个数字</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/04/22/b95fa703eacb5e9b.png)

	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param array int整型vector 
	     * @return int整型vector
	     */
	    vector<int> FindNumsAppearOnce(vector<int>& array) {
	        // write code here
	        int split = 0;
	        for (int i = 0; i < array.size(); i++) {
	            split ^= array[i];
	        }
	
	        int mask = 1;
	        while ((mask & split) == 0) {
	            mask <<= 1;
	        }
	
	        int res1 = 0;
	        int res2 = 0;
	        for (int i = 0; i < array.size(); i++) {
	            if ((array[i] & mask) != 0) {
	                res1 ^= array[i];
	            } else {
	                res2 ^= array[i];
	            }
	        }
	
	        if (res1 > res2) {
	            int tmp = res1;
	            res1 = res2;
	            res2 = tmp;
	        }
	
	        return {res1, res2};
	    }
	};

#### 面试题57：和为S的两个数字 ####

![](https://s3.uuu.ovh/imgs/2023/04/23/136fd8e12f98ff25.png)

	class Solution {
	public:
	    vector<int> FindNumbersWithSum(vector<int> array, int sum) {
	        int left = 0;
	        int right = array.size() - 1;
	        while (left < right && array[left] + array[right] != sum) {
	            if (array[left] + array[right] > sum) {
	                right--;
	            } else {
	                left++;
	            }
	        }
	
	        if (left >= array.size() || array[left] + array[right] != sum) {
	            return {};
	        }
	            
	        return {array[left], array[right]};
	    }
	};

#### 面试题58：左旋转字符串 ####

![](https://s3.uuu.ovh/imgs/2023/04/23/dac1af107a529e86.png)

	class Solution {
	public:
	    string LeftRotateString(string str, int n) {
	        if (str.size() == 0) {
	            return str;
	        }
	
	        int len = n % str.size();
	        reverse(str.begin(), str.begin() + len);
	        reverse(str.begin() + len, str.end());
	        reverse(str.begin(), str.end());
	        return str;
	    }
	};

#### <font color="#0000dd">面试题59：滑动窗口的最大值</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/04/25/e38b54a371b3abeb.png)

	// 单调队列（下标）
	class Solution {
	public:
	    vector<int> maxInWindows(const vector<int>& num, unsigned int size) {
	        vector<int> result;
	        deque<int> dq;
	        int left = 0;
	        int right = size - 1;
	        for (int i = 0 ; i < size; i++) {
	            if (dq.empty()) {
	                dq.push_back(i);
	            } else {
	                while (!dq.empty() && num[dq.back()] < num[i]) {
	                    dq.pop_back();
	                }
	
	                dq.push_back(i);
	            }
	        }
	
	        while (right < num.size()) {
	            left++;
	            right++;
	            result.push_back(num[dq.front()]);
	            while (!dq.empty() && num[dq.back()] < num[right]) {
	                dq.pop_back();
	            }
	
	            dq.push_back(right);
	            if (dq.front() < left) {
	                dq.pop_front();
	            }
	        }
	
	        return result;
	    }
	};

#### <font color="#0000dd">面试题60：n个骰子的点数</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/04/26/77bba0f874189200.png)

	// 1. 回溯暴力搜索
	class Solution {
	public:
	    vector<double> result;
	    int path;
	    void backTracking(int n, int num, int start) {
	        if (n == start) {
	            result[path - n - num]++;
	            return;
	        }
	
	        for (int i = 1; i <= 6; i++) {
	            path += i;
	            backTracking(n, i, start + 1);
	            path -= i;
	        }
	    }
	
	    vector<double> dicesProbability(int n) {
	        path = 0;
	        result.resize(6 * n - n + 1, 0.0);
	        for (int i = 1; i <= 6; i++) {
	            path += i;
	            backTracking(n, i, 0);
	            path -= i;
	        }
	
	        float sumValue = accumulate(result.begin(), result.end(), 0);
	        for (int i = 0; i < result.size(); i++) {
	            result[i] /= sumValue;
	        }
	
	        return result;
	    }
	};

	// 2. 动态规划
	class Solution {
	public:
	    vector<double> dicesProbability(int n) {
	        vector<vector<double>> dp(n, vector<double>(5 * n + 1, 0.0));
	        for (int i = 0; i <= 5; i++) {
	            dp[0][i] = 1.0 / 6.0;
	        }
	
	        for (int i = 1; i < n; i++) {
	            for (int j = 0; j < (5 * (i)) + 1; j++) {
	                for (int k = 0; k <= 5; k++) {
	                    dp[i][j + k] += dp[i - 1][j] / 6.0;
	                }
	            }
	        }
	
	        return dp[n - 1];
	    }
	};

#### 面试题61：扑克牌顺子 ####

![](https://s3.uuu.ovh/imgs/2023/05/03/38c7b4d3d658ebc8.png)

	class Solution {
	public:
	    bool IsContinuous(vector<int> numbers) {
	        int gap = 0;
	        int zeroNum = 0;
	        sort(numbers.begin(), numbers.end());
	        for (int i = 0; i < numbers.size(); i++) {
	            if (numbers[i] == 0) {
	                zeroNum++;
	            } else if (i > 0 && numbers[i - 1] == numbers[i]) {
	                return false;
	            } else if (i > 0 && numbers[i - 1] != 0) {
	                gap += numbers[i] - numbers[i - 1] - 1;
	            }
	        }
	
	        if (zeroNum >= gap) {
	            return true;
	        }
	
	        return false;
	    }
	};

#### 面试题62：孩子们的游戏（圆圈中最后剩下的数） ####

![](https://s3.uuu.ovh/imgs/2023/05/04/104fbe4b62fe7353.png)

	// 暴力搜索
	class Solution {
	public:
	    int LastRemaining_Solution(int n, int m) {
	        vector<bool> isUsed(n, false);
	        int count = 1;
	        int find = 0;
	        int index = 0;
	        while (find < n - 1) {
	            if (isUsed[index] == true) {
	                if (index == n - 1) {
	                    index = 0;
	                } else {
	                    index++;
	                }
	                continue;
	            }
	
	            if (count == m) {
	                count = 1;
	                find++;
	                isUsed[index] = true;
	            } else {
	                count++;
	            }
	
	            if (index == n - 1) {
	                index = 0;
	            } else {
	                index++;
	            }
	        }
	
	        for (int i = 0; i < isUsed.size(); i++) {
	            if (isUsed[i] == false) {
	                index = i;
	                break;
	            }
	        }
	
	        return index;
	    }
	};

	// f(n,m) = (f(n-1,m) + m) % n
	class Solution {
	public:
	    int LastRemaining_Solution(int n, int m) {
	        if (n < 1 || m < 1) {
	            return -1;
	        }
	
	        int last = 0;
	        for (int i = 1; i < n; i++) {
	            last = (last + m) % (i + 1);
	        }
	
	        return last;
	    }
	};

#### 面试题63：买卖股票的最好时机 ####

![](https://s3.uuu.ovh/imgs/2023/05/06/a8375c46e45fa18e.png)

	class Solution {
	public:
	    /**
	     * 
	     * @param prices int整型vector 
	     * @return int整型
	     */
	    int maxProfit(vector<int>& prices) {
	        // write code here
	        int maxValue = 0;
	        int minValue = prices[0];
	        for (int i = 1; i < prices.size(); i++) {
	            minValue = min(prices[i], minValue);
	            maxValue = max(prices[i] - minValue, maxValue);
	        }
	
	        return maxValue;
	    }
	};

#### <font color="#0000dd">面试题64：求1+2+3+...+n</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/05/06/36a192211664c01f.png)

	class Solution {
	public:
	    int Sum_Solution(int n) {
	        //通过与运算判断n是否为正数，以结束递归
	        n && (n += Sum_Solution(n - 1));
	        return n;
	    }
	};

#### <font color="#0000dd">面试题65：不用加减乘除做加法</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/05/08/b8f3ffa97eaa5a5f.png)

	class Solution {
	public:
	    int Add(int num1, int num2) {
	        int result = 0;
	        int carry;
	        while (carry != 0) {
	            result = (num1 ^ num2);
	            carry = (num1 & num2) << 1;
	            num1 = result;
	            num2 = carry;
	        }
	
	        return result;
	    }
	};

#### <font color="#0000dd">面试题66：构建乘积数组</font><br /> ####

![](https://s3.uuu.ovh/imgs/2023/05/09/09ffae1ce29137a4.png)

	// 看成对角线为1的二维矩阵
	class Solution {
	public:
	    vector<int> multiply(const vector<int>& A) {
	        vector<int> array1(A.size(), 1);
	        vector<int> array2(A.size(), 1);
	        for (int i = 1; i < A.size(); i++) {
	            array1[i] = array1[i - 1] * A[i - 1];  
	        }
	
	        for (int i = A.size() - 2; i >= 0; i--) {
	            array2[i] = array2[i + 1] * A[i + 1];
	            array2[i + 1] *= array1[i + 1];
	        }
	
	        return array2;
	    }
	};


### <a name="chapter7"></a>第七章

#### 面试题67：把字符串转换成整数（atoi） ####

![](https://s3.uuu.ovh/imgs/2023/05/10/f8b13174cfb0bac8.png)

	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param s string字符串 
	     * @return int整型
	     */
	    int StrToInt(string s) {
	        // write code here
	        int flag = 1;
	        int start = 0;
	        long long int result = 0;
	        while (s[start] == ' ') {
	            start++;
	        }
	
	        for (int i = start; i < s.size(); i++) {
	            if (i == start) {
	                if (s[i] == '-') {
	                    flag = -1;
	                } else if (s[i] == '+') {
	                    flag = 1;
	                } else if (s[i] < '0' || s[i] > '9') {
	                    return 0;
	                } else {
	                    result += s[i] - '0';
	                }
	            } else {
	                if (s[i] < '0' || s[i] > '9') {
	                    if (s[i] == ' ') {
	                        return result * flag;
	                        continue;
	                    } else if (result) {
	                        return result * flag;
	                    } else {
	                        return 0;
	                    }
	                } else {
	                    result = result * 10 + (s[i] - '0');
	                    if (result >= 2147483648) {
	                        if (flag > 0) {
	                            return 2147483647;
	                        }  else {
	                            return -2147483648;
	                        }
	                    }
	                }
	            }
	        }
	
	        return result * flag;
	    }
	};

#### 面试题68：二叉搜索树的最近公共祖先 ####

![](https://s3.uuu.ovh/imgs/2023/05/10/5c9cc56d678f150e.png)

	// 未使用二叉搜索树特性
	/**
	 * struct TreeNode {
	 *	int val;
	 *	struct TreeNode *left;
	 *	struct TreeNode *right;
	 *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
	 * };
	 */
	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param root TreeNode类 
	     * @param p int整型 
	     * @param q int整型 
	     * @return int整型
	     */
	    TreeNode* posrOrder(TreeNode* node, int p, int q) {
	        if (node == nullptr) {
	            return nullptr;
	        }
	
	        TreeNode* left = posrOrder(node->left, p, q);
	        TreeNode* right = posrOrder(node->right, p, q);
	        if (node->val == p || node->val == q) {
	            return node;
	        }
	
	        if (left && right) {
	            return node;
	        } else if (left) {
	            return left;
	        } else if (right) {
	            return right;
	        }
	
	        return nullptr;
	    }
	
	    int lowestCommonAncestor(TreeNode* root, int p, int q) {
	        // write code here
	        TreeNode* node = posrOrder(root, p, q);
	        if (node) {
	            return node->val;
	        }
	
	        return 0;
	    }
	};

	// 前序遍历，只需要找到第一个在区间[p, q]中的值即可
	/**
	 * struct TreeNode {
	 *	int val;
	 *	struct TreeNode *left;
	 *	struct TreeNode *right;
	 *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
	 * };
	 */
	class Solution {
	public:
	    /**
	     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
	     *
	     * 
	     * @param root TreeNode类 
	     * @param p int整型 
	     * @param q int整型 
	     * @return int整型
	     */
	    TreeNode* preOrder(TreeNode* node, int p, int q) {
	        if (node == nullptr) {
	            return nullptr;
	        }
	
	        if (node->val >= p && node->val <= q) {
	            return node;
	        }
	
	        TreeNode* left = preOrder(node->left, p, q);
	        TreeNode* right = preOrder(node->right, p, q);
	
	        if (left) {
	            return left;
	        }
	
	        if (right) {
	            return right;
	        }
	
	        return nullptr;
	    }
	
	    int lowestCommonAncestor(TreeNode* root, int p, int q) {
	        // write code here
	        if (p > q) {
	            int temp = p;
	            p = q;
	            q = temp;
	        }
	
	        TreeNode* node = preOrder(root, p, q);
	        if (node) {
	            return node->val;
	        }
	
	        return 0;
	    }
	};

### 参考资源

* [nowcoder](https://www.nowcoder.com/exam/oj/ta?page=1&tpId=13&type=13)

转载请注明：[sizheluo的博客](https://sizheluo.github.io) » [JZ_Note](https://sizheluo.github.io/2023/03/JZ_Note/)