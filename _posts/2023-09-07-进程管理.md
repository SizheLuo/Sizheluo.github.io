---
layout: post
title: "进程管理"
date: 2023-09-07
description: "进程管理"
tag: 操作系统
---

### 前言

　　`前言`内容。

### 目录

* [第一章](#chapter1)
* [第二章](#chapter2)
* [第三章](#chapter3)
* [第四章](#chapter4)
* [第五章](#chapter5)
* [第六章](#chapter6)
* [第七章](#chapter7)
* [第八章](#chapter8)

### <a name="chapter1"></a>进程

1. 并行、并发
2. 进程的状态：运行状态、就绪状态、阻塞状态、创建状态、结束状态、阻塞挂起状态、就绪挂起状态
3. 进程控制块PCB：链表->相同的状态、task_struct->mm_struct->vm_area_struct
4. 上下文切换： 

		(1) CPU上下文切换：CPU寄存器和程序计数器
		(2) 进程上下文切换：虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源；发生场景：时间片调度、系统资源不足暂时挂起、sleep、高优先级抢占、中断
5. 进程通信：由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。

		(1) 管道：int pipe(int fd[2])、匿名管道（只能在父子进程通信）、命名管道（p设备文件、先进先出）
		(2) 消息队列：send、receive、涉及用户态与内核态之间的消息拷贝
		(3) 共享内存（多进程竞争问题）
		(4) 信号量：两个原子操作-P操作&V操作
		(5) 信号：异常情况下的工作模型，需要用信号的方式通知进程，用`kill -l`命令，查看所有的信号

![](https://s3.uuu.ovh/imgs/2023/09/09/1d075237841da82a.png)

		(6) Socket：跨网络进程通信，int socket(int domain, int type, int protocal)

![](https://s3.uuu.ovh/imgs/2023/09/09/5f387c37bb63e59b.png)

- 服务端和客户端初始化`socket`，得到文件描述符；
- 服务端调用`bind`，将绑定在IP地址和端口;
- 服务端调用`listen`，进行监听；
- 服务端调用`accept`，等待客户端连接；
- 客户端调用`connect`，向服务器端的地址和端口发起连接请求；
- 服务端`accept`返回用于传输的`socket`的文件描述符；
- 客户端调用`write`写入数据；服务端调用`read`读取数据；
- 客户端断开连接时，会调用`close`，那么服务端`read`读取数据的时候，就会读取到了`EOF`，待处理完数据后，服务端调用`close`，表示连接关闭。

这里需要注意的是，服务端调用 accept 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。

所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作监听 socket，一个叫作已完成连接 socket。

### <a name="chapter2"></a>线程

1. 线程间共享代码段、数据段、打开的文件等资源，但各自有一套独立的寄存器和栈
2. 线程上下文切换：

		(1) 不同进程的线程，则与进程上下文切换基本一致
		(2) 同属于一个进程，虚拟内存等资源保持不变，只需切换私有数据、寄存器和栈等不共享数据
3. 线程的实现：用户线程、内核线程、轻量级进程
4. 线程控制块TCB

### <a name="chapter3"></a>进程与线程的比较

1. 进程是资源（包括内存、打开的文件等）分配的基本单位，线程是CPU调度的基本单位
2. 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈
3. 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系
4. 线程能减少开销：

        (1) 创建快、释放快
		(2) 切换快，不需要切换页表等
		(3) 共享进程内存和文件资源，通信开销小

### <a name="chapter4"></a>调度

1. 调度时机：
		
		(1) 非抢占式调度算法：让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程
		(2) 抢占式调度算法：让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。需要在时间间隔的末端发生时钟中断，也就是常说的时间片机制
2. 调度算法

		(1) 先来先服务(First Come First Serve, FCFS)
		(2) 最短作业优先(Shortest Job First, SJF)
		(3) 高响应比优先(Highest Response Ratio Next, HRRN)
		(4) 时间片轮转(Round Robin, RR)
		(5) 最高优先级(Highest Priority First, HPF)
		(6) 多级反馈队列(Multilevel Feedback Queue,MFQ)

### <a name="chapter5"></a>进程通信

    第五章内容

### <a name="chapter6"></a>第六章

    第六章内容

### <a name="chapter7"></a>第七章

    第七章内容

### <a name="chapter8"></a>第八章

    第八章内容

### 参考资源

    参考资源

转载请注明：[sizheluo的博客](https://sizheluo.github.io) » [文章标题](文章链接)